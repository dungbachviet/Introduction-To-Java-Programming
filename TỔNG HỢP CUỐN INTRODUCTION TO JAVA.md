
# TỔNG HỢP CUỐN INTRODUCTION TO JAVA PROGRAMMING - AUTHOR : Y. DANIEL LIANG

## CHƯƠNG 12 : EXCEPTION HANDLING AND TEXT I/O - Trang 449

- Mục 12.1, 12.2 (tr450) : Tác giả trình bày tổng quan về Exception và Lợi ích mà nó đem lại thông qua các ví dụ : 
  - Listing 12.1, 12.2, 12.3 : Tác giả đưa ra ví dụ sau : Giả sử ta cần phải thiết kế một phương thức (method) để tính thương của 2 số nguyên nhập vào. Khi phương thức đó nhận được 2 tham số này để tính thương, vậy điều gì sẽ xảy ra nếu Tham số thứ 2 bằng 0 (Lỗi chia cho 0). Rõ ràng lúc này, bên trong phương thức đó ta cần phải tính toán và thiết kế thêm một đoạn If để check điều kiện cho tham số thứ 2 phải khác 0. Cụ thể hơn bên trong vòng If đó ta cần phải đưa ra các hướng xử lý cho tình huống này: 
	- Hoặc ngay lập tức thoát khỏi chương trình (dùng exit(1)) ==> Thoát đột ngột, Thiết kế không hiệu quả
	- Hoặc sẽ thông báo người dùng nhập lại ==> Vậy điều gì xảy ra : Nếu với cùng một Exception (lỗi chia cho 0) tại các ngữ cảnh khác nhau thì người ta lại muốn xử lý theo các chiến lược khác nhau (chẳng hạn : thông báo nhập lại, hoặc tự động thiết lập giá trị mặc định,...)??? Ta không nên "đặt cứng" một hướng xử lý ngoại lệ bên trong phương thức được mà hãy để tùy thuộc vào từng bối cảnh khác nhau thì sử dụng một chiến lược xử lý ngoại lệ hợp lý ==> Đó mới là cách thiết kế chuyên nghiệp và dễ kế thừa.
	
  - Vậy cần phải thiết kế như thế nào mới hợp lý :
    - Listing 12.4 (tr452) : Thay vì đặt đồng thời 2 nhiệm vụ : Phát hiện Exception và Xử lý Exception trong cùng 1 method được gọi, thì ta hãy phân tách nó ra : Nhiệm vụ phát hiện Exception được giao cho method (khi method phát hiện ra exception thì nó sẽ phóng exception ra bằng lệnh throw new Tên_Exception()), còn nhiệm vụ Xử lý Exception sẽ được thực hiện bởi caller (nơi mà gọi tới method tính toán thương của 2 số nguyên như trên. Tại caller này, method sẽ được bao bọc bởi Try ... Catch. Nếu method không phóng ra Exception thì chương trình sẽ thực hiện hết các lệnh trong khối Try và bỏ qua các khối Catch. Còn nếu có bất kỳ Exception nào được phóng ra từ trong khối try nghĩa là từ một method nào đó thì nó sẽ nhảy đến khối Catch tương ứng để xử lý loại exception này. Chú ý rằng : Có thể trong khối try có thể chứa đựng nhiều method, mà mỗi method lại có thể phóng ra các loại Exception khác nhau, do vậy cần phải có nhiều khối catch để bắt được tương ứng các Exception đó). Ta hãy quan niệm : Exception thực chất chính là một đối tượng mà thôi, bản chất bên trong class của Exception này cũng không có gì phức tạp cả. Constructor của nó chỉ có tham số String để cho biết Nội dung hay Tên gợi nhắc của Exception này. Vậy ý nghĩa của String (tham số) truyền vào Exception này là gì ? Với Exception thuộc class ArithmeticException như : new ArithmeticException("Lỗi chia cho 0") và new ArithmeticException("Lỗi chia cho một biến không phải là số"). Nếu trong caller (bao bọc bởi khối try..catch) chứa cả 2 phương thức mà có thể phóng ra 2 Exeption "cùng loại mà khác kiểu" như thế này thì phải giải quyết ra sao? Có lẽ lúc đó phải dựa vào thêm số String truyền vào thì mới phân biệt được mỗi exception và có hướng giải quyết tương ứng.
	
	- Listing 12.5 (454) : 
	  - Tác giả muốn nói rằng Tất cả các phương thức có sẵn của thư viện đều đã được trang bị đầy đủ để phóng ra các Exception có tiềm năng xảy ra đối với nó. Lập trình chỉ cần biết : Đối với phương thức này có thể sẽ phóng ra những Exception loại nào, từ đó ở phần caller (lời gọi tới method đó) tại khối Catch sẽ bắt đầy đủ các Exception và xử lý theo ý riêng của Lập trình viên.
	  - Chú ý khi sử dụng : x = input.nextInt() với input là đối tượng của Scanner rằng : sau khi người dùng nhập vào từ bàn phím thì ngay sau lệnh x = input.nextInt() ta nên thêm vào lệnh input.nextLine() để xóa bỏ dòng (buffer) của lần nhập vừa xong (tránh lần nhập sau phải bị dùng lại). Chẳng hạn như : Tại lần nhập này nếu người dùng nhập nhiều số như : 5 6 7, mà nếu sau x = input.nextInt() ta không có input.nextLine() thì sau khi đọc được 5, thì tại lệnh input.nextInt() kết tiếp trong tương lại thì nó sẽ lại đọc tiếp 6 (nguyên nhân : do buffer của System.in trong quá khứ chưa được xóa) ==> Hãy thật lưu ý điều này !!!
	  
- Mục 12.3 (tr455) : Các kiểu Exception - Mọi Exception đều là lớp con (cháu) từ lớp gốc : Throwable
  - Hãy chú ý rằng : Mọi Exception đều là đối tượng, vì thế chúng phải có Class để định nghĩa ra chính mình (exception). Do vậy những lỗi nào mà không có Class biểu diễn nó thì nó không được gọi là Exception (như Lỗi cú pháp không thể gọi là Exception được). Do vậy, những lỗi mà có thể biểu diễn được thông qua một Class (có thể là Class có sẵn cho exception, hoặc Class do ta tự tạo) thì mới được coi là Exception ==> Như vậy, ta đã hiểu rõ : Thế nào là Exception !!!
  - Bên trong Exception thì lại chia thành nhiều dạng khác nhau : 
    - System Error (class Error): Chứa các class mà định nghĩa cho các Exception do lỗi từ bên trong hệ thống gây ra mà lập trình viên ít có khả năng tác động vào được như : Lỗi kết nối (Class LinkageError), Lỗi về máy ảo (Class VirtualMachineError). Khi gặp những lỗi này, ta thường phải ngừng chương trình đang chạy.
	- Exceptions gồm các dạng chính : 
	  - Checked Exceptions : Là kiểu exception mà Compiler (Trình dịch) có khả năng phát hiện và yêu cầu, bắt buộc Lập trình viên phải thêm vào các đoạn Try...catch tương ứng xử lý, ví dụ : IOException (Ngoại lệ về Lỗi Đọc/Ghi File, thông thường trình biên dịch sẽ yêu cầu LTV phải thêm các đoạn xử lý ngoại lệ Try ... catch), hoặc ClassNotFoundException (Lỗi Class không tồn tại, lỗi này có thể phát hiện được bởi Compiler)
	  - Unchecked Exceptions : Là kiểu exception mà chỉ tại running time mới biết được là có xảy ra lỗi hay không? Nghĩa là trình dịch không thể kiểm soát, lường trước được ngoại lệ này. Ví dụ như : ArithmeticException (lỗi chia cho 0, rõ ràng : khi có 2 biến x, y và lấy x/y thì trình biên dịch sẽ chẳng đủ thông minh để hiểu được x/y đang thiếu xử lý những ngoại lệ gì, do vậy Lập trình viên phải tự chủ động bắt Try ... catch cho những ngoại lệ này), NullPointerException(Sử dụng một tham chiếu NULL - chưa trỏ đến đối tượng nào cả), IndexOutOfBoundsException(Sử dụng index vượt quá giới hạn của mảng), IllealArgumentException(sd tham số truyền vào không hợp lệ)
	  
	  
- Mục 12.4 (tr458) : Tác giả trình bày sâu hơn về Exception : 
  - Mô hình xử lý Exception trong Java gồm 3 bước : Khai báo Exception, Phóng ra Exception, Bắt(xử lý) Exception.
    - 12.4.1 : Khai báo Exception (tr458): nghĩa là thêm "throws tên_exception" vào phía sau phần khai báo tên của phương thức (method). Vậy khi nào cần phải có sự khai báo này, và việc khai báo Exception cho phương thức như thế này thì có chức năng là gì? Như ta đã biết có loại exception chính là : checked exception (exception được kiểm soát được bởi Compiler) và unchecked exception (exception không kiểm soát được bởi Compiler). 
	  - Với method có checked exception : Cần throws exception đó trong method, đồng thời khai báo checked exception tại header của method (phía sau tên method) (xem trang 458). Mục đích : Mỗi khi có một caller gọi tới method này thì trình biên dịch sẽ dựa trên khai báo checked exception trên method đó và yêu cầu bắt buộc LTV phải có đoạn Try...catch xử lý, hoặc ít nhất nếu chưa muốn chưa xử Checked Exception tại caller này thì phải tiếp tục khai báo Checked Exception đó trên caller đang gọi (để những caller phía trước sẽ biết và yêu cầu LTV phải xử lý Try ... catch). Chú ý : nếu trong 1 phương thức mà có thể phóng ra nhiều checked exception thì ta cần phải khai báo đủ chúng trên phần header (mỗi exception sẽ cách nhau bởi 1 dấu phẩy)
	  - Với method chỉ có unchecked exception : Thì không cần phải khai báo throws exception bởi vì đây là unchecked exception tức là ngoại lệ mà khó hay không thể kiểm soát bởi compiler (vì các unchecked exception rất là phức tạp và nhiều dạng nên trình biên dịch không đủ thông minh để tự động phát hiện được do vậy LTV phải chủ động phòng ngừa). Vậy nếu ta cố tình vẫn khai báo unchecked exception đó tại header của phương thức thì sao? Khi compiler nhìn thấy sự khai báo exception đó, compiler sẽ biết đó là : unchecked hay checked exception. Nên khi compiler biết đó là : unchecked exception thì compiler sẽ "lờ đi" và "coi như không có sự khai báo này". Để chứng minh sự "lờ đi" của compiler đối với unchecked exception ta có nhìn vào ví dụ sau : nếu tại một lời gọi hàm (caller) tới method đang chứa unchecked exception mà có khai báo thì tại caller nếu ta không có Try...catch hoặc cũng không có throws exception này thì compiler cũng không báo lỗi vì nó biết đây là unchecked exception nên việc phòng ngừa phải do lập trình viên đảm nhận và test thật kỹ !!!
	- 12.4.2 : Phóng ra Exception (tr458-459): Bên trong một phương thức nếu ta nghi ngờ dòng code này có thể xảy ra ngoại lệ thì ta cần phải check trường hợp ngoại lệ đó (xem có xảy ra không), nếu khi xảy ra thì sẽ phóng ra đối tượng ngoại lệ tương ứng với nó theo cú pháp : throw new Tên_Ngoại_Lệ();. Chú ý : Bản chất thì ngoại lệ cũng là một đối tượng nên phải có "new". Từ khóa "throw" trong thao tác phóng ngoại lệ cũng khác với từ khóa "throws" (có thêm s) trong thao tác khai báo ngoại lệ tại header ==> Chú ý !!!  
	- 12.4.3 : Bắt ngoại lệ (tr459-461) : Đây chính là giai đoạn để tìm ra Đoạn xử lý ngoại lệ tương ứng với ngoại lệ đang được phóng ra. Giả sử : Tại main() ta có gọi tới method1(), bên trong method1() ta gọi đến method2(), rồi bên trong method2() ta gọi đến method3(). Bên trong method3() là method có khả năng phát ra ngoại lệ exception1. Khi exception1 được phát ra thì nó sẽ tìm trong các khối Catch trong method3() để tìm ra đoạn xử lý tương ứng với nó, nếu tìm được thì nó sẽ thực hiện khối đó rồi thực hiện tiếp các lệnh sau khối catch (bỏ qua phần còn lại trong khối try). Nhưng nếu không tìm thấy thì sao, hoặc trong method3() không có đoạn try...catch xử lý mà phóng ra (throw) exception đó? Lúc này, chương trình sẽ lần tới method2() tức method cha (method gọi tới method3), rồi lại kiểm tra tương tự trong method2 này. Nếu trong method2 chỉ có throw exception hoặc có try...catch nhưng trong các khối catch thì không tìm thấy đoạn xử lý tương ứng. Lúc này chương trình lại lần tới method1(),... quá trình kiểm tra tương tự. Nếu vẫn không tìm thấy thì rõ ràng chương trình sẽ phóng ra exception và ngừng lại đột ngột !!!

  - 12.4.4 : Cách lấy thông tin từ Exception () (tr461) Tác giả trình bày về cách sử dụng các phương thức lấy thông tin từ một exception bắt được trong khôi Catch ví dụ như : printStackTrace() (lấy thông tin về : tên exception được phóng ra, và nơi xảy ra exception đó,...), toString(), getMessage(),....
  
- Mục 12.5 : Sử dụng Finally (tr466): Khối finally được đặt sau khối Try...catch với mục đích rằng : dù có hay không xảy ra exception thì chương trình sẽ luôn phải thực hiện khối finally đó (thậm chí : ngay cả khi phía trước của finally là một lệnh return)

- Mục 12.6 - Khi nào sẽ nên sử dụng Exception (tr467) : Tác giả nói rằng không lạm dụng Exception một cách bừa bãi (lúc nào cũng sử dụng) mà hãy nên cân nhắc xem : đó là lỗi mà có thể lường trước hay khó lường trước được? Nếu nó là một lỗi "dễ lường trước" và "ít xuất hiện - xuất hiện cá biệt chỉ trong class đó" thì nên sử dụng If () để xử lý luôn. Còn nếu đó là một lỗi "khó lường trước và có thể xuất hiện trong một vài class" thì hãy nên sử dụng Exception (có thể đó là Exception của thư viện hoặc Exception mà ta tự tạo kế thừa từ Exception của thư viện)

- Mục 12.7 - Phóng ra lại Exception (tr468) : Nghĩa là trong khối Catch xử lý exception đó mà ta không xử lý mà lại tiếp tục phóng nó (throw exception). Java có cho phép điều này nhằm đẩy việc xử lý ngoại lệ cho một caller phía trước nó!!!
- Mục 12.8 - Chuỗi exeption (tr469) : Tác giả trình bày các in ra một chuỗi các exception ==> Phần này không quan trọng lắm.
- Mục 12.9 - Định nghĩa một Exception mới. Có một vài điều cần chú ý : 
  - Ta muốn exception mới này là : checked exceptioin hay unchecked exception. Nếu muốn nó sẽ là checked exception thì phải extends class này với class Exception, còn nếu muốn nó sẽ là uncheck exception thì hãy extends nó với RuntimeException. Tác giả khuyên nên sử dụng và tạo ra kiểu checked exception để compiler có thể chủ động nhắc chúng ta thêm các đoạn xử lý ngoại lệ hoặc các đoạn khai báo trên header (nếu ta chưa muốn xử lý ngoại lệ tại ví trí này, và muốn nhường việc xử lý ngoại lệ cho caller phía trước nó)
  - Ví dụ 12.10, 12.11 : Tác giả đưa ra ví dụ về cách tạo ra một Checked Exception. Bản chất của Exception cũng không có gì phức tạp. Nó giống như một thành phần mà Java thêm vào giúp phân tách quá trình phát hiện và xử lý ngoại lệ thành nhiều bước tách rời như Khai báo ngoại lệ, Phóng ngoại lệ và Xử lý ngoại lệ, nhằm giúp cho quá trình code sẽ chuyên nghiệp và dễ hiểu hơn!!!
	  
- 12.10 :(tr473) Tác giả hướng dẫn các sử dụng class File nhằm quản lý một file hay một folder trong máy tính như : xem file/folder có tồn tại, tạo file/folder, đổi tên file/folder, xem kích thước, xóa,...Chú ý rằng File chỉ giúp quản lý lý thông tin gắn với thuộc tính của file hoặc folder chứ lớp này không có tính năng đọc hay ghi file đâu nhé (khi đó cần phải sử dụng lớp Scanner để đọc file text và lớp PrintWriter để ghi vào file text)

- 12.11 (tr476) : Cách sử dụng PrintWriter để ghi file text và sử dụng Scanner để đọc file text. Có một vài chú ý sau : 
  - PrintWriter và Scanner được hiểu là các Stream ghi/đọc từ file nào đó. Ta cần phải truyền vào các PrintWriter hay Scanner một đối tượng File sẽ đọc (đối tượng này đã bàn ở 12.10, nhằm quản lý file đó, kiểm tra file đó có tồn tại, ...). Còn nếu ta muốn đọc từ bàn phím thì truyền vào constructor của Scanner là System.in (đầu vào chuẩn từ bàn phím trong java)
  - PrintWriter, Scanner : có checked exception là IOException được phóng ra khi File đọc vào không tìm thấy (không tồn tại). Do là checked exception nên compiler sẽ buộc yêu cầu Lập trình viên phải có đoạn Try ... Catch xử lý hoặc phải khai báo nó ra tại header của caller đó
  - Thông thường lập trình viên hay quên gọi lệnh close() để giải phóng tài nguyên sử dụng file. Do vậy JDK7 sẽ hỗ trợ thêm cú pháp Try-with-resourse nhằm tự động đóng tài nguyên(close()) sau khi đọc xong file. Đừng nhầm lẫn là nó sẽ giải quyết hộ luôn Exception mà Lập trình viên vẫn phải có đoạn xử lý exception cho nó nhé!!!
  - 12.11.4 (tr479): Tác giả nói rõ hơn cách hoạt động của Scanner như : cách Scanner lấy token ra sao,... để từ đó ta có thành thạo các thao tác liên quan tới đọc file text sd Scanner
  - 12.11.5 (tr480): Trình bày ví dụ về các Thay thế text trong 1 file

- 12.12 :(tr482) Trình bày ví dụ về cách đọc text từ URL (Link trên web). Do không đọc từ File trên máy tính mà đọc từ URL nên ta cũng phải sử dụng một đối tượng thuộc lớp URL để quản lý URL đó
- 12.13 (tr484) : Tác giả trình bày các crawler các link từ một trang web ban đầu theo kỹ thuật quét theo chiều rộng (nghĩa là với một trang web ta sẽ quét hết các URL trong đó, rồi lại truy nhập vào từng URL rồi lại quét... cho tới khi quét đủ 100 URL thì dừng lại)  
	  
	  
# CHƯƠNG 13 (tr496)- ABSTRACT CLASSES AND INTERFACES

- Mục 13.6  (tr509) Tìm hiểu về interface Comparable
  - Comparable là Generic Inteface (nghĩa là có khuôn dạng Comparable<E>, trong đó E cho biết đối tượng được quản lý và kiểm soát bởi Comparable phải là E, tức không được là bất kỳ một kiểu dữ liệu nào khác E. Từ điều này, Compiler chỉ cần nhìn vào khai báo Comparable<E> như Comparable < Integer > thì compiler sẽ báo lỗi nếu ta cố truyền vào tham số mà có kiểu dữ liệu khác E như Double (vì Double khác Integer. Còn nếu không sử dụng Generic mà chỉ sử dụng kiểu đối tượng cha là Object thì compiler sẽ không thể phát hiện được lỗi tại thời điểm biên dịch chương trình vì mọi đối tượng đều có kiểu Object, do vậy sẽ vô cùng nguy hiểm khi lỗi sẽ xuất hiện tại Run Time. Kiến thức Generic sẽ được trình bày trong chương 19-tr737)
  - Comparable là interface mà chỉ có duy nhất một phương thức ảo là compareTo(E doi_tuong); Hãy để ý phương thức này được truyền vào một đối tượng phải có kiểu là E (E là kiểu đã được chỉ được từ trước trong các khai báo kiểu như Comparable<Integer> hoặc Comparable<Double>,... thì E sẽ buộc phải là Integer và Double một cách tương cách)
  - java.util.Arrays.sort(mảng_đối_tượng) sẽ thực hiện sắp xếp mảng các đối tượng (thuộc cùng class), nếu class của các đối tượng này phải implements interface Comparable tức phải override phương thức compareTo() theo cách định nghĩa so sánh giữa các đối tượng này.
  - Các kiểu dữ liệu đối tượng có sẵn trong Java đều đã được implements interface Comparable. Ví dụ như : class Integer đã được java implements Comparable < Integer >, do vậy bản chất Integer thì java đã phải override cho nó với phương thức compareTo(Integer đối_tượng). Hãy để ý kỹ : tại sao Integer lại implements Comparable < Integer > mà không phải Comparable, hay Comparable <> (hiểu là Comparable < Object > ) hay Comparable < Double >  bởi vì : class mong muốn được so sánh là class Integer để tham số truyền vào của phương thức compareTo phải là Integer (compareTo(Integer đối_tượng)) (vì chỉ được so sánh 2 đối tượng thuộc cùng kiểu), hơn nữa : Comparable là generic inteface tức phải chỉ rõ cho compiler biết E trong Comparable<E> là class nào để compiler có thể phát hiện lỗi tại thời gian biên dịch.
  - Khi override phương thức compareTo, kiểu trả về là int với 3 giá trị -1, 0, 1 tương ứng với đối tượng hiện tại nhỏ hơn, bằng hay lớn hơn đối tượng cần so sánh (chỉ định trong tham số). Ta buộc phải return đủ 3 giá trị này trong phương thức compareTo để JVM có thể hiểu rõ được thao tác so sánh của Lập trình viên (từ đó tránh được lỗi lưỡng nghĩa)
  - Phía sau tác giả trình bày các ví dụ cụ thể minh họa rõ ràng cách sử dụng Comparable
  
- Mục 13.7 (tr513) - Tìm hiểu về interface Cloneable :
  - Clonable là marker interface nghĩa là bên trong interface là rỗng (không có bất kỳ phương thức nào). Một class khi implements interface Clonable thì sẽ được JVM đánh dấu (là có thể clonable) và sẽ được sử dụng phương thức clone() trong lớp cha lớn nhất (Object). Ngược lại, nếu không implements Clonable mà cố tình gọi phương thức clone() của lớp cha (Object) thì tại run time sẽ phóng ra exception CloneNotSupportedException (nghĩa là : ta chưa implements Clonable);
  - Các kiểu dữ liệu (class) có sẵn trong Java đều đã được implements Clonable (như Integer, Double, ArrayList,....)
  - Khi ta muốn định nghĩa một class mới có khả năng clonable thì cần phải làm như sau : 
    - Cho class đó implements Clonable
	- Bên trong class này, tiến hành override phương thức Clone của lớp cha Object, về bản chất thì nó sẽ gọi đến chính clone() của lớp cha Object (bằng cách super.clone()) nhưng mở rộng phạm vi nhìn thấy của phương thức này ra thành public (việc mở rộng giúp một đối tượng có thể gọi được phương thức này ở Package chứa class đó) (Xem kỹ ví dụ : House.java, tr514-515)
	- Phương thức clone trong class Object chứa Checked Exception là CloneNotSupportedException, nên khi bất cứ khi nào ta gọi đến phương thức clone của Objec thì compiler luôn yêu cầu : hoặc phải xử lý exeption đó bằng Try..catch hoặc Phải khai báo Exception đó ra (throws CloneNotSupportedException tại header của phương thức mà đang sử dụng clone của Object đó)
	
  - Vấn đề shallow copy và deep copy : 
    - Hiện tượng shallow copy xảy ra khi đối tượng được nhân bản lại chứa các thuộc tính dạng tham chiếu (con trỏ), thậm chí đối tượng mà thuộc tính tham chiếu này trỏ tới có thể lại tiếp tục chứa một dạng tham chiếu khác,... Trong khi clone() chỉ là nhân bản "nông", nó không đủ thông minh để tìm kiếm và nhân bản cho tất cả các tham chiếu (phụ thuộc) ở đằng sâu bên trong.
    - Ví dụ : Khi ta sử dụng ArrayList < Interger >  arr1 = ..., sau đó sử dụng ArrayList < Integer >  arr2 = (ArrayList < Integer > ) arr1.clone(); ==> Ở đây xảy ra hiện shallow copy. Nghĩa là : Rõ ràng arr1, và arr2 nằm ở 2 vùng nhớ hoàn toàn khác nhau tức arr1 != arr2 (không cùng trỏ đến 1 vùng nhớ, khác tham chiếu), nhưng arr1 và arr2 lại chứa cùng danh sách các con trỏ giống hệt nhau, nghĩa là nếu : arr1.get(0).setDoTuoi(100) thì arr2.get(0) cũng sẽ bị thay đổi theo vì 2 con trỏ này đang cùng trỏ tới một vùng nhớ ==> Đây chính là vấn đề : Shallow Copy
	- Để ngăn ngừa Shallow Copy xảy ra thì Lập trình viên phải chủ động phát hiện và lường trước để tiến hành override phương thức clone() giúp tạo ra 2 đối tượng "độc lập thực sự" như tác giả trình bày trong ví dụ tr516, với ý tưởng như sau : 
	  - Khi override phương thức Clone() thì cần phải để tâm tới những thuộc tính dạng tham chiếu rồi tiến hành clone riêng cho từng dạng tham chiếu đó. Làm tương tự, nếu các tham chiếu còn ở sâu sâu bên trong cho tới khi gặp tham chiếu tới đối tượng mà chỉ chứa toàn các kiểu thuộc tính dữ liệu "nguyên thủy" (như int, float, double,...)

- Mục 13.8 (tr517) - Trình bày sự khác nhau giữa Interface và Abstract Class
  - Về kiểu dữ liệu của thuộc tính : 
    - Interface : buộc phải là public static final (tức kiểu hằng, tĩnh, public). Java đã mặc định luôn như vậy nên dù ta có viết như thế nào thì java cũng sẽ chỉ hiểu theo kiểu này
    - Atract Class : không có ràng buộc (giống như thuộc tính trong class bình thường)
	
  - Về kiểu dữ liệu trả về của phương thức : 
    - Interface : buộc phải là public abstract (tức phải luôn là phương thức ảo và có phạm vi nhìn thấy là public). Java đã mặc định luôn như vậy nên dù ta có viết như thế nào thì java cũng sẽ chỉ hiểu theo kiểu này
    - Atract Class : không có ràng buộc (có thể là phương thức abstract hoặc là phương thức bình thường như trong class)
  
  
  - Ta không thể sử dụng new tên_interface() hoặc new tên_abstract_class() vì chúng chỉ là kiểu dữ liệu trừu tượng, nhưng ta có thể thực hiện uploading như sau : 
    - tên_interface obj = new subClass_của_interface(); hoặc tên_abstract_class obj = new subClass_của_abstract_class(); (uploading - ý nghĩa : dùng một kiểu dữ liệu trừu tượng để chứa các đối tượng thuộc kiểu dữ liệu con của nó). 
    - Vậy còn downloading có nghĩa gì? Ta cần phân tích cụ thể như sau : Giả sử có interface1/hoặc abstract1 là cha của class1, class2, class3. Có dòng code : interface1/abstract1 obj = new class2(); (hiện tượng uploading). Đối với interface1 thì luôn chỉ có các phương thức ảo, còn với abstract1 thì có thể có phương thức ảo hoặc phương thức thực (không ảo)
      - obj chỉ gọi tới hay nhìn thấy được các phương thức như sau : 
	    - Là phương thức ảo trong interface1 hoặc phương thức ảo trong abstract1 nhưng đã được cài đặt (định nghĩa) trong class2. Với các phương thức loại này thì hiển nhiên obj này sẽ gọi đến các phương thức nằm trong class2
		- Là phương thức "thực" trong abstract1 mà không bị override trong class2 ==> Hiển nhiên, obj sẽ gọi đến phương thức nằm trong class cha (abstract1) vì class2 (lớp con) không định nghĩa phương thức này.
		- Là phương thức "thực" trong abstract1 mà có override trong class2 ==> obj sẽ gọi đến phương thức nằm trong lớp con (bởi vì đó là phương thức cụ thể nhất)
	  - obj sẽ không thể gọi tới được các phương thức mà đã được bổ sung trong lớp con, nhưng lại không có mặt trong lớp cha (interface1/abstract1) vì góc nhìn sau khi uploading là góc nhìn của lớp cha (chỉ nhìn thấy các phương thức của lớp cha). Vậy câu hỏi đặt ra là làm sao để có thể nhìn thấy và sử dụng được những phương thức được bổ sung thêm tại các lớp con??? Để làm được điều này, ta cần phải downloading (ép kiểu) xuống chính lớp con đó (góc nhìn của lớp con đó), ví dụ như : obj = (Class2) obj. Lúc này ta có thể nhìn thấy mọi phương thức nằm trong lớp Class 2 và nằm trong mọi lớp cha của nó. Nhưng vấn đề tiếp theo là : làm sao để biết obj là thuộc class2 hay class1 hay class3 (vì 3 class này đều là con của interface1/abstract1) ==> Cần sử dụng toán tử instanceof để kiểm tra : obj instanceof Class1 có trả về true không !!! (tương tự)
  
  - Interface và Abstract Class được sinh ra nhằm chỉ định một Kiểu đối tượng "trừu tượng" như Animal(động vật), ở đây ta không biết được Animal là Cat, Dog, hay Elephent ... Còn một class bình thường sẽ dùng để mô tả cho một class cụ thể. Kiểu dữ liệu trừu tượng này sẽ giúp chứa những đặc điểm chung nhất (thuộc tính, phương thức) của các class con. Vậy sự khác biệt chính giữa Interface và Abstract Class là gì?
    - Abstract Class : 
	  - Tên của Abstract Class luôn là danh từ
	  - Dùng để biểu diễn quan hệ is-a relationship (quan hệ "là") và đó phải là quan hệ thể hiện mạnh mẽ. Ví dụ như : Cat là Animal, Dog cũng là Animal ... Từ đó, người ta định nghĩa Animal như một Abstract Class. Hoặc ví dụ khác : LichDuong (Lịch Dương) cũng là Lich (Lịch), LichAm (Lịch Âm) cũng là Lich, do vậy Lich sẽ là Abstract Class 
	  - Hãy để ý thật kỹ : nếu Abstract Class là Animal thì subclass của nó chắc chắn phải là một dạng animal như Dog, Cat,...không thể là một Đồ ăn hay đồ uống được. Hoặc nếu Abstract Class là Lịch thì subclass của nó chắc chắn cũng là một loại lịch cụ thể như Lịch Âm, Lịch Dương, không thể là một đồ vật hay một loại nước ngọt được.
	
	- Interface : 
	  - Tên của interface : có thể là tính từ hoặc danh từ
	  - Biểu diễn cho quan hệ is-a relationship nhưng là quan hệ yếu. Ví dụ : trong java có interface Comparable (hiểu là : biểu diễn một đặc điểm, một thuộc tính là có thể so sánh). Các class con có thể là : Square implement Comparable (hình vuông) , Retangle implements Comparable (hình chữ nhật),... ==> Chúng biểu thị rằng : Các hình vuông có thể so sánh được với nhau, các hình chữ nhật có thể so sánh được với nhau. Nó là quan hệ yếu bởi vì : Nó chỉ biểu thị rằng : Square hay Rectangle đều sở hữu tính chất (thuộc tính) Comparable (có thể so sánh được). Do vậy, khi muốn biểu diễn việc sở hữu một tính chất hay một thuộc tính thì hãy sử dụng interface.
	  - Các subclass của interface không nhất thiết phải cùng kiểu mà chỉ cần nó sở hữu tính chất đó là được. Ví dụ, ta có thể tạo một lớp con cho Comparable là : Hình vuông, Hình chữ nhật, Bó rau, Ngôi nhà, ... dù Bó rau, Ngôi nhà, Hình vuông đều không cùng dạng hình nhưng chúng đều có thể so sánh được. Như vậy, đây là một đặc trưng rất rõ của interface
  ==> Từ 3 đặc trưng trên ta có thể phân biệt được rõ : khi nào thì cần interface, khi nào thì cần tới abstract class.
	
## CHƯƠNG 17 : BINARY I/O
- 17.1, 17.2, 17.3 (tr678) : Tác giả trình bày về sự khác nhau giữa Text I/O và Binary I/O :
  - Text I/O sử dụng Scanner (Đọc file text) và PrintWriter (Ghi file text) như đã biết trong chương 12
  - Máy tính thì luôn hiểu các file ở dạng nhị phân? Vậy thì sự khác nhau giữa text i/o và binary i/o là gì? 
    - Đối với Text I/O thì sẽ có thêm quá trình encoding và decoding. Nó sẽ hiểu mọi ký tự trong file text đều bằng 1 byte, ví dụ với số 199, thì nó sẽ mã hóa cho từng "1", "9", "9" với các byte sau : 0x31, 0x39, 0x39 (viết theo hệ 16). Việc encoding là để coding từng ký tự thành từng byte (vì nó coi mọi ký tự để là ký tự dạng chữ, dù cho nó là số đếm), còn decoding để dùng khi đọc từ file nhị phân rồi decoding nó sang dạng hệ cơ số 10 là "199", rồi từ "199" lập trình viên mới có thêm lệnh ép kiểu về dạng int như sau : (int)"199" hay bản chất chính là (int)input.nextInt();
	- Đối với Binary I/O thì không có quá trình encoding và decoding mà nó mã hóa trực tiếp : giả sử số 199 sẽ được mã hóa thành 0xC17 (nghĩa là chỉ cần 1 byte để biểu diễn số này, chứ không phải mất tới tận 3 byte như Text I/O)
  - Tác giả nói rằng : Binary I/O hiệu quả hơn Text I/O bởi vì nó cần phải mất thêm quá trình encoding và decoding, hơn nữa cũng tiết kiệm vùng nhớ hơn so với Text I/O.
  
- 17.4 (tr680) : Trình bày về các class sử dụng cho Binary I/O : Có 2 lớp cha lớn nhất trong Binary I/O là InputStream và OutStream (chúng đều là interface). Các lớp này đều chỉ có các phương thức đọc ghi theo từng byte
  - 17.4.1 : (tr681) Trình bày 2 lớp con kế thừa từ 2 lớp cha interface này là : FileInputStream và FileOutputStream. Hai lớp này chỉ định nghĩa lại các phương thức từ 2 lớp cha, chứ không thêm vào phương thức mới. Do vậy, chúng sẽ chỉ toàn các phương thức đọc ghi theo byte. Cách đọc ghi theo byte thì sẽ phù hợp khi ta đọc toàn bộ file, còn nếu muốn đọc và lấy ra một số int trong file đó thì rất khó, chỉ số int là 4 byte trong khi nó chỉ đọc có 1 byte, nên chẳng biết nên ghép các byte lại như thế nào cả ==> Do vậy, Java sinh ra 2 lớp giúp ta có thể lấy được các kiểu dữ liệu khác như Int, Double, String....
  
  - 17.4.2, 17.4.3: (tr684)Tác giả trình bày 2 class mới là DataInputStream và DataOutputStream được kế thừa từ 2 lớp tương ứng FilterInputStream và FilterOutputStream. 2 lớp trên (DataInputStream và DataOutputStream) sẽ kế thừa thêm từ 1 interface khác là DataInput/DataOutput chứa đựng các phương thức giúp lấy ra được các kiểu dữ liệu như Int, Double, String,... Bên trong 2 class này sẽ định nghĩa lại các method bên trong DataInput/DataOutput. Do vậy, chúng ta có thể ghi/đọc các kiểu dữ liệu Int, double, float, string.... mà không bị giới hạn chỉ bị ghi/đọc được theo byte như FileInputStream và FiletputStream. Có một lưu ý thêm : Tác giả hay sử dụng writeUTF/readUTF để ghi và đọc string vì đây là cách sử dụng UTF8 với cách mã hóa linh hoạt (Đại khái : với những ký tự ASCII nó sẽ mã hóa bằng 1 byte, với những ký tự khác sẽ mã hóa có thể bằng 2 hoặc 3 byte...). Tác giả nói rằng : hàm writeUTF/readUTF là hiệu quả.
  
  - 17.4.4 : (tr688) Tác giả giới thiệu thêm một stream giúp tăng hiệu suất của quá trình đọc/ghi nhờ sử dụng buffer, nghĩa là : không cần phải thường xuyên thao tác với File (bộ nhớ ngoài) mà giao tiếp thông qua một buffer. Buffer này chỉ lấy một lượng lớn dữ liệu từ File để cho chương trình dùng dần, hoặc ta sẽ ghi hết dữ liệu vào buffer đến khi buffer đầy thì buffer mới đẩy vào file. Hai lớp quản lý buffer đó là : BufferedInputStream và BufferOutputStream. Tham số truyền vào cho BufferOutputStream và BufferedInputStream tương ứng là các đối tượng của Outputstream và InputStream. Để hiểu đơn giản ta hãy quan niệm các kiểu stream chứa dữ liệu như trên là các đoạn đường ống, mỗi đoạn đường ống sẽ có một nhiệm vụ. Ta có thể kết hợp nhiều đoạn đường ống này với nhau nhằm cho quá trình đọc ghi hoạt động tốt nhất có thể. 
    - Ví dụ : 
	  - DataOutputStream output = new DataOutputStream(new BufferedOutputStream(new FileOutputStream("temp.dat"))); : được ghép bởi các đường ống sau : DataOutputStream (đường ống giúp ghi các kiểu dữ liệu tùy ý) --> BufferOutputStream (đường ống sử dụng cơ chế Buffer nhằm tăng hiệu quả của thao tác i/o) --> FileOutputStream (đường ống quả lý dữ liệu theo từng byte) --> File (File dữ liệu ở bộ nhớ ngoài (ổ cứng) của máy tính)
	  - DataInputStream input = new DataInputStream(new BufferedInputStream(new FileInputStream("temp.dat"))); : tương tự cũng được ghép bởi các đường ống DataInputStream (đường ống giúp đọc các kiểu dữ liệu tùy ý) <-- BufferOutputStream (đường ống sử dụng cơ chế Buffer nhằm tăng hiệu quả của thao tác i/o) <-- FileOutputStream (đường ống quả lý dữ liệu theo từng byte) <-- File (File dữ liệu ở bộ nhớ ngoài (ổ cứng) của máy tính)
	- Từ việc hiểu được các kiểu stream (các đường ống với từng chức năng riêng) ta có thể phối hợp các đường ống theo tiêu chí của bài toán một cách phù hợp và hiệu quả nhất.
	
- 17.5 (tr691) : Tác giả trình bày một ví dụ về cách copy từ một file nọ sang file kia.

- 17.6 (tr692) : Tác giả trình bày các đọc và ghi đối tượng object vào file nhị phân nhờ sử dụng ObjectInputStream và ObjectOutputStream. Vậy các lớp này có những chức năng gì? ObjectInputStream được kết thừa từ InputStream (nên có các hàm đọc ghi theo byte), kế thừa từ interface ObjectInput mà ObjectInput lại kết thừa từ interface Datainput (nên vừa các hàm đọc theo từng kiểu dữ liệu cụ thể như int, double, String,..., vừa có hàm readObject trong ObjectInput để đọc được cả đối tượng từ file), ngoài ra thì nó còn kế thừa interface ObjectStreamConstants. Tương tự với sơ đồ kết thừa của ObjectOutputStream. Tác giả đã trình bày khá dễ hiểu trong ví dụ demo.
  - 17.6.1 : (tr695) : Tác giả lưu ý về interface Serializable? Ý nghĩa của interface này là gì? 
    - Tác giả nói rằng : Một đối tượng chỉ có thể được đọc/ghi theo kiểu object vào 1 file nhị phân khi và chỉ khi class của đối tượng này có implements Serializable. Về bản chất thì Serializable chỉ là một interface rỗng (bên trong class của nó không có method), người ta còn gọi là : marker interface. Ví dụ : Khi ta định nghĩa một class C và muốn lưu một đối tượng của class C này dưới dạng object trong file nhị phân, lúc này ta cần phải implements cho class C với Serializable, còn nếu không implements Serializable thì chương trình sẽ báo lỗi và xuất ra ngoại lệ NotSerializableException. Có một câu hỏi đặt ra là : Nếu bên trong class C (đã implements Serializable) chứa một đối tượng thuộc lớp A khác mà lớp A đó chưa implements Serializable, vậy thì đối tượng của lớp C này có thể được lưu dưới dạng đối tượng vào file không? Câu trả lời là : Không vì đối tượng của lớp A (nằm trong class C) chưa được Serializabled. Ta có 2 cách sửa tình huống này : Hoặc sẽ thêm implements Serializable cho lớp A (tức đối tượng của lớp A cũng sẽ được lưu vào file), Hoặc "lờ đi" đối tượng của lớp A trong class C bằng cách thêm vào từ khóa transient trước đối tượng đó (như trong ví dụ trang 695, lúc này đối tượng của lớp A sẽ không được lưu vào file). Một chú ý nữa : Các trường thuộc tính dạng static trong đối tượng C sẽ không được lưu theo dạng Object (nghĩa là JVM sẽ chủ động bỏ đi trường này trong đối tượng object được lưu vào file, điều này cũng dễ hiểu bởi vì biến static là biến của class chứ không phải là biến của object nên việc JVM không lưu trường này là hoàn toàn hợp lý!!!).
	
	- Các kiểu dữ liệu có sẵn trong java đều đã được implements Serializable rồi nhé!!!
	- Vậy có khi nào cùng một object sẽ bị ghi vào nhiều lần trong trong file nhị phân hay không? Câu trả lời là không. Bởi vì hình như với mỗi object khi implements Serializable sẽ được gắn với một mã serial number nhằm phân biệt và tránh một đối tượng bị ghi vào nhiều lần trong file.
	- Còn đối với bản thân các class ObjectInputStream và ObjectOutputStream cũng đã được Java implements một dạng Object Serialization rồi giúp các stream này có thể lưu trữ được cả một mảng hay một ArrayList chứa các đối tượng đã implements Serializable ()
	
  - 17.6.2 (tr696) : Tác giả trình bày về cách lưu đối tượng dạng Array như int[], float[], String[]... theo dạng object. Rõ ràng ta nhìn thấy int, float,... đều là kiểu dữ liệu nguyên thủy không phải đối tượng hay tham chiếu. Nhưng bản thân mảng int[] lại là một kiểu đối tượng (con trỏ) nên Java cũng cho phép lưu kiểu đối tượng mảng (của các kiểu dữ liệu nguyên thủy này)
  
  
## CHƯƠNG 19 (tr738): GENERICS 
- Mục 19.1, 19.2 : Tác giả trình bày về lợi ích và công dụng của Generic
  - Generic là một cách giúp tham số hóa trước kiểu dữ liệu (ngay trong dòng code) để trình biên dịch hiểu, kiểm soát và có thể ngăn ngừa được các lỗi về dùng sai kiểu ngay tại thời gian biên dịch chương trình.
  - Trong sách tác giả đã chỉ ra một số ví dụ sau : 
    - Ví dụ 1 : Ta nhận thấy Comparable trong java là một generic interface, nghĩa là Comparable luôn phải đi cùng với <E> tức Comparable<E> trong đó E là kiểu dữ liệu mà nó sẽ quản lý và kiểm soát. Nếu Comparable<Integer> thì phương thức so sánh bên trong interface này sẽ là : compareTo(Integer obj), nếu Comparable<Double> thì phương thức so sánh bên trong interface sẽ là : compareTo(Double obj). Tùy thuộc vào việc ta định nghĩa E là kiểu dữ liệu nào mà tham số truyền vào trong các phương thức của interface Comparable sẽ bị thay đổi một cách tương ứng. Như vậy người ta gọi là : "sự tham số hóa kiểu dữ liệu". Vậy tại sao cần phải tham số hóa kiểu? Bởi vì : nếu khi đã tham số hóa như Comparable<Integer> thì phương thức compareTo() sẽ nhận vào tham số kiểu Integer, mà sẽ báo lỗi (tại thời gian biên dịch) khi truyền vào nó kiểu Double (hay một kiểu dữ liệu khác Integer), điều này khiến cho chương trình trở nên "đáng tin cậy hơn" rất nhiều. Trước đây khi Comparable vẫn chỉ là một interface bình thường, chưa được generic thì phương thức compareTo sẽ có dạng : compareTo(Object obj). Hãy để ý rằng : kiểu tham số của compareTo lúc này là Object, tức ta có thể truyền vào mọi đối tượng thuộc các kiểu dữ liệu khác nhau dù cho kiểu dữ liệu có không phù hợp với phép so sánh đi chăng nữa (tức compiler luôn cho đi qua tại compiling time), nhưng nó sẽ phóng ra lỗi tại run time (lỗi so sánh khác kiểu đối tượng vì người ta mong muốn 2 kiểu đối tượng thuộc cùng Integer sẽ so sánh với nhau). Để làm được điều này (chỉ 2 đối tượng thuộc cùng kiểu thì mới có thể so sánh được với nhau) thì java đã là như sau :class Integer implements Comparable<Integer> {...}. Sau khi Integer được kế thừa từ Comparable<Interger> thì Integer được kế thừa (và định nghĩa lại) phương thức method compareTo(Integer obj) bên trong Comparable<Integer>, như vậy phương thức compareTo này chỉ cho phép tham số truyền vào là một đối tượng Integer ==> Do đó, nếu tại thời điểm biên dịch có bất kỳ một đối tượng kiểu khác truyền vào thì sẽ bị báo lỗi ngay lập tức.
	
	- Ví dụ 2 : ArrayList<E> trong java là một generic class chứa các đối tượng thuộc cùng kiểu dữ liệu E (tức được tham số hóa kiểu dữ liệu trước). Ví dụ : ArrayList<Integer> thì ArrayList chỉ được chứa (chỉ được truyền vào nó) các kiểu đối tượng thuộc kiểu Interger. Bởi vì khi khai báo ArrayList<Integer> thì E sẽ được gán là Integer. Do vậy, các phương thức thêm phần tử của class ArrayList<Integer> sẽ có dạng : add(Integer obj), set(int index, Integer obj), add(int index, Integer obj),... nghĩa là các phương thức này chỉ cho phép truyền vào kiểu đối tượng là Integer, nếu không trình biên dịch sẽ tự động báo lỗi tại complied time. Việc tham số hóa trước kiểu dữ liệu, sẽ giúp compiler biết chắc chắn kiểu dữ liệu mà ArrayList đang hứng, từ đó khi thực hiện get(int index) để lấy đối tượng về thì ta không thiết phải ép kiểu thành Integer nữa vì lúc này compiler đã biết chắc chắn nó là Integer rồi (vì nó dựa vào E đã được gán là Integer).
	
- Mục 19.3 :(tr740) Trình bày các định nghĩa Generic Class và Generic Interface
  - Cách khai báo generic ta thực hiện như sau : 
    - Đối với class cần generic ta chỉ cần thêm vào <E> ngay sau class đó, ví dụ class Animal<E>
	- Đối với phương thức : Do đã khai báo E tại header của class rồi, lúc này ta có thể sử dụng E như một kiểu dữ liệu bình thường vậy. Do vậy, đối với phương thức : E có thể là kiểu dữ liệu của tham số, hoặc có thể là kiểu dữ liệu trả về (làm như phương thức bình thường)
	- Đối với constructor : thì không được khai báo <E> như : public Animal<E>(){} mà chỉ cần public Animal(){} là Java hiểu (xem tr742 phần Caution)

- Mục 19.4 (tr742) : Tác giả nói rằng : ta có thể khai báo một class không là generic class, nhưng bên trong class đó có thể chứa một phương thức static mà là generic static method (bởi vì về bản chất thì phương thức tĩnh sẽ độc lập với đối tượng của class, nên mới có thể class không là generic nhưng phương thức static vẫn có thể là generic)
  - Việc khai báo việc một phương thức tĩnh dạng generic, nên ta phải có cơ chế để chỉ rõ compiler biết <E> trong phương thức tĩnh đó là gì? Cách làm như sau : public static <E> void print(E[] list). Đừng nhầm, <E> không phải là kiểu trả về nhé, kiểu trả về trong phương thức này là void. <E> chỉ để khai báo trước hay gán trước E là kiểu dữ liệu nào để từ đó ta có thể sử dụng E như một kiểu dữ liệu bình thường. Hoặc có một ví dụ khác : public static <E> int method(E obj, int a, String b), trong phương thức tĩnh này : ta đã chỉ rõ trước E, nên có thể sử dụng E như một kiểu dữ liệu trong tham số truyền vào. Vậy khi nào ta sẽ biết E đang được gán là kiểu dữ liệu gì? E sẽ được gán (được chỉ định) bởi lập trình viên khi gọi phương thức tĩnh đó như sau : Tên_Class.<Integer>print(listIntegers); nó sẽ gán Integer cho E, mà E[] lại là kiểu dữ liệu của tham số list truyền vào, do vậy phương thức này chỉ nhận các tham số có dạng Integer[] mà không nhận bất kỳ kiểu dữ liệu nào khác như Double[], String[]... ==> Do vậy, ta thấy được sự an toàn và đáng tin cậy khi sử dụng generic !!!
  
  - Chú ý rằng : Nếu chỉ khai báo <E> thì tại java chỉ hiểu E là một kiểu dữ liệu nào đó, mà sẽ được truyền vào tại running time, nên compiler sẽ không biết được E sẽ được gán bởi kiểu dữ liệu nào : Integer hay Double hay String,... đều không thể biết chắc được. Nên mỗi khi sử dụng <E> là ta đang sử dụng một kiểu dữ liệu tổng quát, do vậy góc nhìn của E cũng là góc nhìn tổng quát hay đúng ra thì E sẽ chỉ nhìn thấy được các phương thức của Object (vì Object là phương thức cha của mọi đối tượng). Do vậy, người ta chỉ sử dụng <E> với mục đích : Khi muốn có một kiểu dữ liệu tổng quát, và kiểm soát được kiểu dữ liệu truyền vào (phải thống nhất với kiểu dữ liệu mà người dùng truyền vào tại running time). Còn nếu muốn sử dụng góc nhìn cụ thể hơn góc nhìn của Object thì phải làm như sau : <E extends Integer>. Người ta gọi đây là bounded (có giới hạn), khi làm theo cách này thì E cũng đã cụ thể hơn và không còn tổng quát nữa, nên góc nhìn của E sẽ là góc nhìn của Integer tức sẽ có các phương thức của Integer. Giả sử rằng, nếu Integer có nhiều lớp con như Integer1, Integer2, Integer3 thì E có thể là kiểu bất kỳ trong số các lớp con miễn là thỏa mãn : E extends Integers. Ví dụ : public static <E extends Integer> void max (E obj1, E obj2). Lúc này obj1 và obj2 có thể khác kiểu dữ liệu nhau nhưng kiểu dữ liệu của chúng phải thỏa mãn đều extends Integer, nghĩa là obj1 có thể thuộc Integer1, còn obj2 có thể thuộc Integer3 chẳng hạn. Tại vì sao có thể làm như vậy? Bởi vì góc nhìn của E là góc nhìn của Integer, nên E chỉ nhìn thấy những phương thức trong Integer, mà không nhìn thấy các phương thức mà Integer1,2,3 có mà Integer không có. Do vậy E chỉ cần thuộc lớp con của Integer (hoặc thuộc chính Integer) thì đều chấp nhận được !!! ==> Hãy cố gắng hiểu được bản chất !!!

- 19.6 : Trình bày một ví dụ để làm rõ những điều trên
- 19.7 : Tác giả trình bày 3 ký hiệu wildcard trong generic. Chú ý rằng : 3 ký pháp này không phải là một sự viết tắt cho <T> ở phần trước, mà người ta sử dụng 3 kí hiệu này giúp bổ sung thêm những tầng nghĩa mới như : <? extends T> (đầu tiên khi T được gán bởi một kiểu nào đó, lúc này ? tượng trưng cho bất kỳ kiểu dữ liệu nào mà hoặc là T hoặc là lớp con của T, như vậy đến T và ? ta đều chưa biết tại thời điểm biên dịch, nhưng ta biết được mối quan hệ giữa chúng), <? super T> (? tượng trưng cho các lớp mà là lớp cha của lớp T), <?> (? tượng trưng cho một lớp bất kỳ, chẳng cần có quan hệ nào với T cả)
  - Ký hiệu <?> : Ám chỉ có thể truyền vào một kiểu dữ liệu bất kỳ, ví dụ : public static void print(GenericStack<?> stack). Ta hãy phân tích dòng code này : Dòng code này cho phép nhận tham số là bất kỳ đối tượng thuộc kiểu GenericStack<Integer> hoặc GenericStack<Object>,... <?> ám chỉ cho mọi kiểu
  - Ký hiệu <? super T> : Ví dụ public static <T> void add(GenericStack<T> stack1, GenericStack<? super T> stack2)
    - Trong lệnh này : ta có khai báo thêm kiểu <T>, rồi tiếp tục khai báo quan hệ <? super T> nhằm ám chỉ rằng : khi T được gán tại thời gian runtime, thì ? sẽ là bất kỳ kiểu lớp cha nào của T. Nên GenericStack<? super T> sẽ là : GenericStack<T> hoặc là GenericStack<Lớp_Cha_Của_T>,...
  - Ký hiệu <? extends T> : Ngược lại ý nghĩa của <? super T>. Ví dụ public static <T> void add(GenericStack<? extends T> stack1, GenericStack<T> stack2) == (giống với lệnh) public static <T> void add(GenericStack<T> stack1, GenericStack<? super T> stack2). Do vậy, GenericStack<? extends T> sẽ được hiểu là : Ta có truyền vào bất kỳ đối tượng thuộc kiểu sau : GenericStack<T> hoặc GenericStack<Lớp_Con_Của_T>.
	
## CHƯƠNG 20 : (tr 762) - Trình bày các Collection của Java như List, Stack, Queue, Priority Queue



## Chapter 30 - Multithreading and Parallel Programming - Lập trình đa luồng (song song)

30.1. Introduction
30.2. Thread Concepts (1098) : Giới thiệu về mô hình lập trình đa luồng (lợi ích về mặt thời gian và tận dụng tài nguyên của CPU,...)
30.3. Creating Tasks and Threads (1098) : Hướng dẫn cách tạo mô hình lập trình đa luồng với các khái niệm Task, Thread
  - Định nghĩa 1 class nhằm hiện một công việc nào đó. Để class này có thể được thực hiện bởi một luồng nào đó thì ta cần phải cho class đó implement interface Runnable. Runnable là interface chỉ có 1 phương thức ảo run(), class của ta cần phải override phương thức ảo này. Vậy bên trong run() (được override bên trong class) dùng để làm gì? Ta sẽ định nghĩa một công việc bên trong phương thức này (giống như định nghĩa một phương thức vậy, nhưng chẳng qua tên của phương thức này là run() thôi). Như vậy 1 task đã định nghĩa.
  - Tiếp theo, làm sao để cho 1 luồng (từ 1 processor nào) thực hiện task này? Tại hàm main (chương trình chính), ta thực hiện tạo đối tượng chứa task cần thực hiện. Sau đó, tạo ra một đối tượng luồng với tham số là đối tượng task cần thực hiện trên. Từ đối tượng luồng đó, ta gọi tới phương thức start() của nó (nghĩa là cho luồng bắt đầu chạy và thực hiện task đó). Về bản chất bên trong, khi một luồng (thread) gọi tới phương thức start() của nó thì JVM sẽ tự động gọi tới phương thức run() bên trong Task (mà ta đã định nghĩa). Chú ý rằng : Ta không được sử dụng đối tượng Task để gọi tới trực tiếp phương thức run() của nó mà buộc phải cần tới 1 luồng để gọi tới start() (rồi run() sẽ được gọi tự động), nếu cố tình gọi trực tiếp thì chương trình sẽ không tạo luồng mới (tức chẳng có luồng mới nào thực hiện cả)!!!

30.4. The Thread Class (1102) : Trình bày cụ thể về lớp Thread 
  - Class Thread implement interface Runnable
  - Chứa các phương thức : start (bắt đầu chạy thread trên task được truyền vào), isAlive(kiểm tra luồng có đang chạy không), setPriority (thiết lập độ ưu tiên cho luồng), join() (chờ đợi 1 luồng khác thực hiện xong thì mới được thực hiện tiếp), sleep (cho phép luồng được ngủ trong bao nhiều miliseconds), yield (nhường cho các luồng khác thực hiện trước), interrupt(để ngắt luồng này).
  - Chú ý : Không nên sử dụng các phương thức stop(), suspend(), resume() (vì nó đã cũ, không sử dụng). Để ngừng 1 luồng, đơn giản ta chỉ cần gán biến đó bằng null.
  - Hướng dẫn cách sử dụng sleep() để thiết lập thời gian ngủ cho luồng (với checked exception)
  - Cách sử dụng join() để luồng A khi thực hiện tới 1 thời điểm nào đó thì phải chờ luồng B phải thực hiện xong thì luồng A mới được thực hiện tiếp.
  - Cách thiết lập mức độ ưu tiên cho các luồng bằng setPriority() với 3 tham số : MIN_PRIORITY, NORM_PRIORITY, MAX_PRIORITY (tương ứng với 3 mức độ ưu tiên nhỏ nhất, trung bình, lớn nhất tương ứng với 1, 5, 10). Mặc định, mỗi luồng có độ ưu tiên bằng 5 (tức NORM_PRIORITY) (ta có thiết lập giá trị cụ thể cho độ ưu tiên từ 1-->10)

30.5. Case Study : Flashing Text - Trình bày về 1 ví dụ hiển thị chữ động (nhấp nháy sử dụng luồng)

30.6. Thread Pools (1106) : Trình bày cách sử dụng Pool (bể) để chứa nhiều luồng. Pool sẽ quản lý tất cả các luồng như : tái sử dụng 1 luồng để thực hiện 1 task khác, tự động tạo thêm luồng mới khi có task mới đến, ... Việc sử dụng Pool sẽ rất linh hoạt trong việc quản lý luồng hơn là cứ mỗi task tạo ra 1 luồng để chạy (như tác giả đã trình bày ở mục trước)

  - Tạo ra đối tượng ExecutorService để quản lý và chứa các luồng bằng cách sau : (gọi tới phương thức static của class Executors để nó trả về 1 đối tượng ExecutorService chuyên quản lý các luồng) Executors.newFixedThreadPool(số_luồng_fix_cứng) hoặc Executors.newCachedThreadPool() (để tạo số luồng một cách động và linh hoạt, tức cứ khi có luồng mới thì nó tạo, nếu luồng đó không cần thiết nữa thì ta sẽ xóa nó đi)
  - Sử dụng newCachedThreadPool linh hoạt hơn newFixedThreadPool
  
30.7. Thread Synchronization - Đồng bộ các luồng
  - Trình bày 1 trường hợp 100 luồng cùng thực hiện đọc và ghi lên tài khoản như sau : Chẳng hạn, ta có 100 luồng, mỗi luồng sẽ lấy số dư của 1 tài khoản A rồi cộng cho tài khoản A 1 dollar. Như vậy, với 100 luồng thì rõ ràng, tài khoản A phải được cộng thêm 100 dollar. Nhưng kết quả chạy lại không cho kết quả như vậy? Nguyên nhân như sau: Tại thời điểm 1, luồng 1 đang đọc số dư tài khoản hiện tại balance. Tại thời điểm 2, luồng 2 đọc số dư tài khoản hiện tại balance. Thời điểm 3, luồng 1 lấy balance đã nhận được rồi cộng thêm 1 và cập nhật số dư. Thời điểm 4, luồng 2 lấy số dư nó đã lấy được từ thời điểm 2 để cộng thêm 1 dollar rồi cập nhật. Như vậy, luồng 2 không hề tận dụng kết quả cập nhật của luồng 1, do vậy dẫn đến kết quả bị sai lệch (luồng 2 ghi đè lên kết quả của luồng 1).
  - Nguyên nhân của vấn đề này, đó là : 2 thao tác đọc số dư và cập nhật tài khoản bị thực hiện riêng rẽ. Để tránh hiện tượng này, ta cần phải đóng gói 2 thao tác trên vào cùng 1 wrapper và chỉ cho phép 1 luồng được chạy trong khối wrapper tại 1 thời điểm
  - Sử dụng từ khóa synchronized đặt trước phương thức truy cập tài nguyên dùng chung này
  
  - ... Sau này khi cần đồng bộ thì đọc thêm
  	
	
## CHƯƠNG 32 : (tr1174) JAVA DATABASE PROGRAMMING
- Mục 32.1, 32.2 (tr1174) 
  - Trình bày tổng quan quá trình sử dụng Cơ sở dữ liệu : Đi từ Người dùng --> Chương trình Ứng dụng--> Hệ thống quản lý CSDL --> Kho CSDL
  - Giới thiệu mô hình CSDL Quan hệ : Một bảng với nhiều thuộc tính, trong đó Bảng được hiểu là một lớp thực thể (như Nhân_Viên, Học_Sinh,...), các thuộc tính được hiểu là các đặc điểm/tính chất gắn với mỗi thực thể trong lớp thực thể (ví dụ : với lớp thực thể là Học Sinh thì các thuộc tính của học sinh có thể là Tên, Tuổi, Quê quán, Giới tính ...). Mỗi bảng có thể chứa nhiều bản ghi (ví dụ : Bảng Học_Sinh thì có học sinh A, học sinh B,...)
  - Trình bày 3 ràng buộc chính giữa các bảng (các quan hệ, thực thể) trong hệ CSDL, đó là : 
    - Ràng buộc về Khóa chính : Mỗi bảng thực thể cần phải chỉ ra tập các thuộc tính đóng vai trò làm khóa chính, mà từ khóa chính này (tập các thuộc tính then chốt này) ta có thể phân biệt được các bản ghi với nhau trong bảng đó. Hiển nhiên với một bảng ta có thể đề xuất nhiều khóa chính, nhưng hãy chọn ra tập các thuộc tính nhỏ nhất và then chốt nhất để làm khóa chính.
	- Ràng buộc về Khóa ngoại : Khi ta đã quan niệm khóa chính hiểu như một ID giúp phân biệt được giữa các bản ghi với nhau trong cùng một Bảng. Vậy thì lúc này, nếu có 2 bảng có quan hệ với nhau như quan hệ cha-con chẳng hạn (cha có thể có nhiều con). Lúc này, với mỗi người con ta cần phải có một sự "truy dẫn" để tìm được về với cha của người con đó. Giả sử : ta có bảng Cha, và có bảng Sinh_Viên, với mỗi bảng đều có một khóa chính riêng. Lúc này, ta bổ sung thêm tập các thuộc tính đang đóng vai trò làm khóa chính của bảng Cha vào tập các thuộc tính của bảng Sinh_Viên. Lúc này, ta gọi : tập các thuộc tính như vậy là : Khóa ngoài của bảng Sinh_Viên tham chiếu tới khóa chính của bảng Cha. Như vậy, với một sinh viên A, ta chỉ cần dựa vào các trường khóa ngoại rồi đem đi tìm trong bảng Cha thì sẽ tìm ra được cha của sinh viên A đó.
	- Ràng buộc về Miền : chẳng hạn ràng buộc về NULL, Unique(phân biệt), Giới hạn miền, ...

- Mục 32.3 (tr1178) Trình bày về các câu truy vấn trong SQL
  - Cách tạo tài khoản User trên MySQL
  - Cách cấp quyền
  - Cách tạo mới Database
  - Cách tạo mới/Xóa bảng
  - Các lệnh update bảng cơ bản như : Chèn, Sửa, Xóa bản ghi
  - Các lệnh truy vấn bản ghi từ bảng
  - Cách sử dụng các toán tử So sánh, Boolean trong câu truy vấn 
  - Cách sử dụng các toán tử So khớp xâu (like), miền giá trị (between), toán tử kiểm tra null (is null)
  - Cách đặt tên giả cho cột
  - Sử dụng các toán tử toán học trong câu truy vấn (cộng, trừ, nhân, chia..)
  - Cách sử dụng Distinct để hiển thị các bản ghi phân biệt
  - Cách hiển thị các bản ghi đã được sắp xếp theo một thứ tự nào đó.
  - Cách join nhiều bảng với nhau để truy vấn (nếu tìm hiểu kỹ thì sẽ có join trong, join trái, join phải, join theo kiểu đề-các)
  
- Mục 32.4 (tr1189) : Tác giả trình bày cách sử dụng thư viện JDBC để truy vấn tới CSDL (Database)
  - 32.4.1 : Tác giả nêu tổng quan của quá trình thao tác với CSDL sử dụng JDBC như sau : 
    - Bước 1 : Khai báo sử dụng Driver (Loading Driver) bằng lệnh Class.forName("Tên_Class_Của_Driver_Sử_Dụng"). Đối với từng hệ quản trị cơ sở dữ liệu khác nhau (MySQL, SQL Server,..) thì sẽ phải phải gọi tới các Driver khác nhau (đã được liệt kê trong bảng 32.3-tr1191). Ta hiểu Driver giống như một công cụ giúp thao tác được với Hệ quản trị CSDL
	- Bước 2 : Thiết lập kết nối tới Database như sau : Connection connection = DriverManager.getConnection(databaseURL); trong đó databaseURL đã được tác giả liệt kê trong bảng (tương ứng với từng Hệ quản trị CSDL)
	- Bước 3 : Tạo ra một đối tượng chứa và thực hiện lệnh SQL : Statement statement = connection.createStatement();
	- Bước 4 : Thực hiện lệnh : 
	  - Thực hiện update bảng : statement.executeUpdate("lệnh SQL để update bảng");
	  - Thực hiện truy vấn để trả kết quả về : ResultSet resultSet = statement.executeQuery("lệnh truy vấn SQL"); sau khi thực thi nó sẽ trả kết quả truy vấn được cho đối tượng resultSet
	- Bước 5 : Xử lý kết quả truy vấn trả về : Sau khi đã lấy được dữ liệu từ database trả về trong biến resultSet, ta tiến hành lấy từng trường dữ liệu trong từng bản ghi trong resultSet để xử lý trong ứng dụng (xem các tác giả demo)
	
  - 32.4.2 : Tác giả nêu một ví dụ trực quan và cụ thể khi sử dụng 5 bước thao tác với CSDL trên trong Java FX (giao diện đồ họa của Java)
 
- Mục 32.5 : Tác giả giới thiệu về kiểu dữ liệu PreparedStatement. Khác với kiểu Statement, thì kiểu PreparedStatement linh hoạt hơn rất nhiều, nó cho phép trong câu truy vấn còn các ký hiệu ? để sau đó ta có thể điền vào sau nhờ các phương thức set tương ứng. Với cách này sẽ khiến cho câu truy vấn được linh hoạt và có thể được tái sử dụng nhiều lần !!!

- Mục 32.6 : Giới thiệu về CallableStatement - Phải hiểu được Thủ tục trong SQL thì nên đọc phần này.
- Mục 32.7 : Trình bày cách lấy các thông tin Metadata (thông tin khác của database như username,URL, Driver name,...) 
	

	
