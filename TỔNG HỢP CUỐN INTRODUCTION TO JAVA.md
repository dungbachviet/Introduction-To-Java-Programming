
# TỔNG HỢP CUỐN INTRODUCTION TO JAVA PROGRAMMING - AUTHOR : Y. DANIEL LIANG

## CHƯƠNG 12 : EXCEPTION HANDLING AND TEXT I/O - Trang 449

- Mục 12.1, 12.2 (tr450) : Tác giả trình bày tổng quan về Exception và Lợi ích mà nó đem lại thông qua các ví dụ : 
  - Listing 12.1, 12.2, 12.3 : Tác giả đưa ra ví dụ sau : Giả sử ta cần phải thiết kế một phương thức (method) để tính thương của 2 số nguyên nhập vào. Khi phương thức đó nhận được 2 tham số này để tính thương, vậy điều gì sẽ xảy ra nếu Tham số thứ 2 bằng 0 (Lỗi chia cho 0). Rõ ràng lúc này, bên trong phương thức đó ta cần phải tính toán và thiết kế thêm một đoạn If để check điều kiện cho tham số thứ 2 phải khác 0. Cụ thể hơn bên trong vòng If đó ta cần phải đưa ra các hướng xử lý cho tình huống này: 
	- Hoặc ngay lập tức thoát khỏi chương trình (dùng exit(1)) ==> Thoát đột ngột, Thiết kế không hiệu quả
	- Hoặc sẽ thông báo người dùng nhập lại ==> Vậy điều gì xảy ra : Nếu với cùng một Exception (lỗi chia cho 0) tại các ngữ cảnh khác nhau thì người ta lại muốn xử lý theo các chiến lược khác nhau (chẳng hạn : thông báo nhập lại, hoặc tự động thiết lập giá trị mặc định,...)??? Ta không nên "đặt cứng" một hướng xử lý ngoại lệ bên trong phương thức được mà hãy để tùy thuộc vào từng bối cảnh khác nhau thì sử dụng một chiến lược xử lý ngoại lệ hợp lý ==> Đó mới là cách thiết kế chuyên nghiệp và dễ kế thừa.
	
  - Vậy cần phải thiết kế như thế nào mới hợp lý :
    - Listing 12.4 (tr452) : Thay vì đặt đồng thời 2 nhiệm vụ : Phát hiện Exception và Xử lý Exception trong cùng 1 method được gọi, thì ta hãy phân tách nó ra : Nhiệm vụ phát hiện Exception được giao cho method (khi method phát hiện ra exception thì nó sẽ phóng exception ra bằng lệnh throw new Tên_Exception()), còn nhiệm vụ Xử lý Exception sẽ được thực hiện bởi caller (nơi mà gọi tới method tính toán thương của 2 số nguyên như trên. Tại caller này, method sẽ được bao bọc bởi Try ... Catch. Nếu method không phóng ra Exception thì chương trình sẽ thực hiện hết các lệnh trong khối Try và bỏ qua các khối Catch. Còn nếu có bất kỳ Exception nào được phóng ra từ trong khối try nghĩa là từ một method nào đó thì nó sẽ nhảy đến khối Catch tương ứng để xử lý loại exception này. Chú ý rằng : Có thể trong khối try có thể chứa đựng nhiều method, mà mỗi method lại có thể phóng ra các loại Exception khác nhau, do vậy cần phải có nhiều khối catch để bắt được tương ứng các Exception đó). Ta hãy quan niệm : Exception thực chất chính là một đối tượng mà thôi, bản chất bên trong class của Exception này cũng không có gì phức tạp cả. Constructor của nó chỉ có tham số String để cho biết Nội dung hay Tên gợi nhắc của Exception này. Vậy ý nghĩa của String (tham số) truyền vào Exception này là gì ? Với Exception thuộc class ArithmeticException như : new ArithmeticException("Lỗi chia cho 0") và new ArithmeticException("Lỗi chia cho một biến không phải là số"). Nếu trong caller (bao bọc bởi khối try..catch) chứa cả 2 phương thức mà có thể phóng ra 2 Exeption "cùng loại mà khác kiểu" như thế này thì phải giải quyết ra sao? Có lẽ lúc đó phải dựa vào thêm số String truyền vào thì mới phân biệt được mỗi exception và có hướng giải quyết tương ứng.
	
	- Listing 12.5 (454) : 
	  - Tác giả muốn nói rằng Tất cả các phương thức có sẵn của thư viện đều đã được trang bị đầy đủ để phóng ra các Exception có tiềm năng xảy ra đối với nó. Lập trình chỉ cần biết : Đối với phương thức này có thể sẽ phóng ra những Exception loại nào, từ đó ở phần caller (lời gọi tới method đó) tại khối Catch sẽ bắt đầy đủ các Exception và xử lý theo ý riêng của Lập trình viên.
	  - Chú ý khi sử dụng : x = input.nextInt() với input là đối tượng của Scanner rằng : sau khi người dùng nhập vào từ bàn phím thì ngay sau lệnh x = input.nextInt() ta nên thêm vào lệnh input.nextLine() để xóa bỏ dòng (buffer) của lần nhập vừa xong (tránh lần nhập sau phải bị dùng lại). Chẳng hạn như : Tại lần nhập này nếu người dùng nhập nhiều số như : 5 6 7, mà nếu sau x = input.nextInt() ta không có input.nextLine() thì sau khi đọc được 5, thì tại lệnh input.nextInt() kết tiếp trong tương lại thì nó sẽ lại đọc tiếp 6 (nguyên nhân : do buffer của System.in trong quá khứ chưa được xóa) ==> Hãy thật lưu ý điều này !!!
	  
- Mục 12.3 (tr455) : Các kiểu Exception - Mọi Exception đều là lớp con (cháu) từ lớp gốc : Throwable
  - Hãy chú ý rằng : Mọi Exception đều là đối tượng, vì thế chúng phải có Class để định nghĩa ra chính mình (exception). Do vậy những lỗi nào mà không có Class biểu diễn nó thì nó không được gọi là Exception (như Lỗi cú pháp không thể gọi là Exception được). Do vậy, những lỗi mà có thể biểu diễn được thông qua một Class (có thể là Class có sẵn cho exception, hoặc Class do ta tự tạo) thì mới được coi là Exception ==> Như vậy, ta đã hiểu rõ : Thế nào là Exception !!!
  - Bên trong Exception thì lại chia thành nhiều dạng khác nhau : 
    - System Error (class Error): Chứa các class mà định nghĩa cho các Exception do lỗi từ bên trong hệ thống gây ra mà lập trình viên ít có khả năng tác động vào được như : Lỗi kết nối (Class LinkageError), Lỗi về máy ảo (Class VirtualMachineError). Khi gặp những lỗi này, ta thường phải ngừng chương trình đang chạy.
	- Exceptions gồm các dạng chính : 
	  - Checked Exceptions : Là kiểu exception mà Compiler (Trình dịch) có khả năng phát hiện và yêu cầu, bắt buộc Lập trình viên phải thêm vào các đoạn Try...catch tương ứng xử lý, ví dụ : IOException (Ngoại lệ về Lỗi Đọc/Ghi File, thông thường trình biên dịch sẽ yêu cầu LTV phải thêm các đoạn xử lý ngoại lệ Try ... catch), hoặc ClassNotFoundException (Lỗi Class không tồn tại, lỗi này có thể phát hiện được bởi Compiler)
	  - Unchecked Exceptions : Là kiểu exception mà chỉ tại running time mới biết được là có xảy ra lỗi hay không? Nghĩa là trình dịch không thể kiểm soát, lường trước được ngoại lệ này. Ví dụ như : ArithmeticException (lỗi chia cho 0, rõ ràng : khi có 2 biến x, y và lấy x/y thì trình biên dịch sẽ chẳng đủ thông minh để hiểu được x/y đang thiếu xử lý những ngoại lệ gì, do vậy Lập trình viên phải tự chủ động bắt Try ... catch cho những ngoại lệ này), NullPointerException(Sử dụng một tham chiếu NULL - chưa trỏ đến đối tượng nào cả), IndexOutOfBoundsException(Sử dụng index vượt quá giới hạn của mảng), IllealArgumentException(sd tham số truyền vào không hợp lệ)
	  
	  
- Mục 12.4 (tr458) : Tác giả trình bày sâu hơn về Exception : 
  - Mô hình xử lý Exception trong Java gồm 3 bước : Khai báo Exception, Phóng ra Exception, Bắt(xử lý) Exception.
    - 12.4.1 : Khai báo Exception (tr458): nghĩa là thêm "throws tên_exception" vào phía sau phần khai báo tên của phương thức (method). Vậy khi nào cần phải có sự khai báo này, và việc khai báo Exception cho phương thức như thế này thì có chức năng là gì? Như ta đã biết có loại exception chính là : checked exception (exception được kiểm soát được bởi Compiler) và unchecked exception (exception không kiểm soát được bởi Compiler). 
	  - Với method có checked exception : Cần throws exception đó trong method, đồng thời khai báo checked exception tại header của method (phía sau tên method) (xem trang 458). Mục đích : Mỗi khi có một caller gọi tới method này thì trình biên dịch sẽ dựa trên khai báo checked exception trên method đó và yêu cầu bắt buộc LTV phải có đoạn Try...catch xử lý, hoặc ít nhất nếu chưa muốn chưa xử Checked Exception tại caller này thì phải tiếp tục khai báo Checked Exception đó trên caller đang gọi (để những caller phía trước sẽ biết và yêu cầu LTV phải xử lý Try ... catch). Chú ý : nếu trong 1 phương thức mà có thể phóng ra nhiều checked exception thì ta cần phải khai báo đủ chúng trên phần header (mỗi exception sẽ cách nhau bởi 1 dấu phẩy)
	  - Với method chỉ có unchecked exception : Thì không cần phải khai báo throws exception bởi vì đây là unchecked exception tức là ngoại lệ mà khó hay không thể kiểm soát bởi compiler (vì các unchecked exception rất là phức tạp và nhiều dạng nên trình biên dịch không đủ thông minh để tự động phát hiện được do vậy LTV phải chủ động phòng ngừa). Vậy nếu ta cố tình vẫn khai báo unchecked exception đó tại header của phương thức thì sao? Khi compiler nhìn thấy sự khai báo exception đó, compiler sẽ biết đó là : unchecked hay checked exception. Nên khi compiler biết đó là : unchecked exception thì compiler sẽ "lờ đi" và "coi như không có sự khai báo này". Để chứng minh sự "lờ đi" của compiler đối với unchecked exception ta có nhìn vào ví dụ sau : nếu tại một lời gọi hàm (caller) tới method đang chứa unchecked exception mà có khai báo thì tại caller nếu ta không có Try...catch hoặc cũng không có throws exception này thì compiler cũng không báo lỗi vì nó biết đây là unchecked exception nên việc phòng ngừa phải do lập trình viên đảm nhận và test thật kỹ !!!
	- 12.4.2 : Phóng ra Exception (tr458-459): Bên trong một phương thức nếu ta nghi ngờ dòng code này có thể xảy ra ngoại lệ thì ta cần phải check trường hợp ngoại lệ đó (xem có xảy ra không), nếu khi xảy ra thì sẽ phóng ra đối tượng ngoại lệ tương ứng với nó theo cú pháp : throw new Tên_Ngoại_Lệ();. Chú ý : Bản chất thì ngoại lệ cũng là một đối tượng nên phải có "new". Từ khóa "throw" trong thao tác phóng ngoại lệ cũng khác với từ khóa "throws" (có thêm s) trong thao tác khai báo ngoại lệ tại header ==> Chú ý !!!  
	- 12.4.3 : Bắt ngoại lệ (tr459-461) : Đây chính là giai đoạn để tìm ra Đoạn xử lý ngoại lệ tương ứng với ngoại lệ đang được phóng ra. Giả sử : Tại main() ta có gọi tới method1(), bên trong method1() ta gọi đến method2(), rồi bên trong method2() ta gọi đến method3(). Bên trong method3() là method có khả năng phát ra ngoại lệ exception1. Khi exception1 được phát ra thì nó sẽ tìm trong các khối Catch trong method3() để tìm ra đoạn xử lý tương ứng với nó, nếu tìm được thì nó sẽ thực hiện khối đó rồi thực hiện tiếp các lệnh sau khối catch (bỏ qua phần còn lại trong khối try). Nhưng nếu không tìm thấy thì sao, hoặc trong method3() không có đoạn try...catch xử lý mà phóng ra (throw) exception đó? Lúc này, chương trình sẽ lần tới method2() tức method cha (method gọi tới method3), rồi lại kiểm tra tương tự trong method2 này. Nếu trong method2 chỉ có throw exception hoặc có try...catch nhưng trong các khối catch thì không tìm thấy đoạn xử lý tương ứng. Lúc này chương trình lại lần tới method1(),... quá trình kiểm tra tương tự. Nếu vẫn không tìm thấy thì rõ ràng chương trình sẽ phóng ra exception và ngừng lại đột ngột !!!

  - 12.4.4 : Cách lấy thông tin từ Exception () (tr461) Tác giả trình bày về cách sử dụng các phương thức lấy thông tin từ một exception bắt được trong khôi Catch ví dụ như : printStackTrace() (lấy thông tin về : tên exception được phóng ra, và nơi xảy ra exception đó,...), toString(), getMessage(),....
  
- Mục 12.5 : Sử dụng Finally (tr466): Khối finally được đặt sau khối Try...catch với mục đích rằng : dù có hay không xảy ra exception thì chương trình sẽ luôn phải thực hiện khối finally đó (thậm chí : ngay cả khi phía trước của finally là một lệnh return)

- Mục 12.6 - Khi nào sẽ nên sử dụng Exception (tr467) : Tác giả nói rằng không lạm dụng Exception một cách bừa bãi (lúc nào cũng sử dụng) mà hãy nên cân nhắc xem : đó là lỗi mà có thể lường trước hay khó lường trước được? Nếu nó là một lỗi "dễ lường trước" và "ít xuất hiện - xuất hiện cá biệt chỉ trong class đó" thì nên sử dụng If () để xử lý luôn. Còn nếu đó là một lỗi "khó lường trước và có thể xuất hiện trong một vài class" thì hãy nên sử dụng Exception (có thể đó là Exception của thư viện hoặc Exception mà ta tự tạo kế thừa từ Exception của thư viện)

- Mục 12.7 - Phóng ra lại Exception (tr468) : Nghĩa là trong khối Catch xử lý exception đó mà ta không xử lý mà lại tiếp tục phóng nó (throw exception). Java có cho phép điều này nhằm đẩy việc xử lý ngoại lệ cho một caller phía trước nó!!!
- Mục 12.8 - Chuỗi exeption (tr469) : Tác giả trình bày các in ra một chuỗi các exception ==> Phần này không quan trọng lắm.
- Mục 12.9 - Định nghĩa một Exception mới. Có một vài điều cần chú ý : 
  - Ta muốn exception mới này là : checked exceptioin hay unchecked exception. Nếu muốn nó sẽ là checked exception thì phải extends class này với class Exception, còn nếu muốn nó sẽ là uncheck exception thì hãy extends nó với RuntimeException. Tác giả khuyên nên sử dụng và tạo ra kiểu checked exception để compiler có thể chủ động nhắc chúng ta thêm các đoạn xử lý ngoại lệ hoặc các đoạn khai báo trên header (nếu ta chưa muốn xử lý ngoại lệ tại ví trí này, và muốn nhường việc xử lý ngoại lệ cho caller phía trước nó)
  - Ví dụ 12.10, 12.11 : Tác giả đưa ra ví dụ về cách tạo ra một Checked Exception. Bản chất của Exception cũng không có gì phức tạp. Nó giống như một thành phần mà Java thêm vào giúp phân tách quá trình phát hiện và xử lý ngoại lệ thành nhiều bước tách rời như Khai báo ngoại lệ, Phóng ngoại lệ và Xử lý ngoại lệ, nhằm giúp cho quá trình code sẽ chuyên nghiệp và dễ hiểu hơn!!!
	  
- 12.10 :(tr473) Tác giả hướng dẫn các sử dụng class File nhằm quản lý một file hay một folder trong máy tính như : xem file/folder có tồn tại, tạo file/folder, đổi tên file/folder, xem kích thước, xóa,...Chú ý rằng File chỉ giúp quản lý lý thông tin gắn với thuộc tính của file hoặc folder chứ lớp này không có tính năng đọc hay ghi file đâu nhé (khi đó cần phải sử dụng lớp Scanner để đọc file text và lớp PrintWriter để ghi vào file text)

- 12.11 (tr476) : Cách sử dụng PrintWriter để ghi file text và sử dụng Scanner để đọc file text. Có một vài chú ý sau : 
  - PrintWriter và Scanner được hiểu là các Stream ghi/đọc từ file nào đó. Ta cần phải truyền vào các PrintWriter hay Scanner một đối tượng File sẽ đọc (đối tượng này đã bàn ở 12.10, nhằm quản lý file đó, kiểm tra file đó có tồn tại, ...). Còn nếu ta muốn đọc từ bàn phím thì truyền vào constructor của Scanner là System.in (đầu vào chuẩn từ bàn phím trong java)
  - PrintWriter, Scanner : có checked exception là IOException được phóng ra khi File đọc vào không tìm thấy (không tồn tại). Do là checked exception nên compiler sẽ buộc yêu cầu Lập trình viên phải có đoạn Try ... Catch xử lý hoặc phải khai báo nó ra tại header của caller đó
  - Thông thường lập trình viên hay quên gọi lệnh close() để giải phóng tài nguyên sử dụng file. Do vậy JDK7 sẽ hỗ trợ thêm cú pháp Try-with-resourse nhằm tự động đóng tài nguyên(close()) sau khi đọc xong file. Đừng nhầm lẫn là nó sẽ giải quyết hộ luôn Exception mà Lập trình viên vẫn phải có đoạn xử lý exception cho nó nhé!!!
  - 12.11.4 (tr479): Tác giả nói rõ hơn cách hoạt động của Scanner như : cách Scanner lấy token ra sao,... để từ đó ta có thành thạo các thao tác liên quan tới đọc file text sd Scanner
  - 12.11.5 (tr480): Trình bày ví dụ về các Thay thế text trong 1 file

- 12.12 :(tr482) Trình bày ví dụ về cách đọc text từ URL (Link trên web). Do không đọc từ File trên máy tính mà đọc từ URL nên ta cũng phải sử dụng một đối tượng thuộc lớp URL để quản lý URL đó
- 12.13 (tr484) : Tác giả trình bày các crawler các link từ một trang web ban đầu theo kỹ thuật quét theo chiều rộng (nghĩa là với một trang web ta sẽ quét hết các URL trong đó, rồi lại truy nhập vào từng URL rồi lại quét... cho tới khi quét đủ 100 URL thì dừng lại)  
	  
	  
# CHƯƠNG 13 - ABSTRACT CLASSES AND INTERFACES


  
## CHƯƠNG 17 : BINARY I/O
- 17.1, 17.2, 17.3 (tr678) : Tác giả trình bày về sự khác nhau giữa Text I/O và Binary I/O :
  - Text I/O sử dụng Scanner (Đọc file text) và PrintWriter (Ghi file text) như đã biết trong chương 12
  - Máy tính thì luôn hiểu các file ở dạng nhị phân? Vậy thì sự khác nhau giữa text i/o và binary i/o là gì? 
    - Đối với Text I/O thì sẽ có thêm quá trình encoding và decoding. Nó sẽ hiểu mọi ký tự trong file text đều bằng 1 byte, ví dụ với số 199, thì nó sẽ mã hóa cho từng "1", "9", "9" với các byte sau : 0x31, 0x39, 0x39 (viết theo hệ 16). Việc encoding là để coding từng ký tự thành từng byte (vì nó coi mọi ký tự để là ký tự dạng chữ, dù cho nó là số đếm), còn decoding để dùng khi đọc từ file nhị phân rồi decoding nó sang dạng hệ cơ số 10 là "199", rồi từ "199" lập trình viên mới có thêm lệnh ép kiểu về dạng int như sau : (int)"199" hay bản chất chính là (int)input.nextInt();
	- Đối với Binary I/O thì không có quá trình encoding và decoding mà nó mã hóa trực tiếp : giả sử số 199 sẽ được mã hóa thành 0xC17 (nghĩa là chỉ cần 1 byte để biểu diễn số này, chứ không phải mất tới tận 3 byte như Text I/O)
  - Tác giả nói rằng : Binary I/O hiệu quả hơn Text I/O bởi vì nó cần phải mất thêm quá trình encoding và decoding, hơn nữa cũng tiết kiệm vùng nhớ hơn so với Text I/O.
  
- 17.4 (tr680) : Trình bày về các class sử dụng cho Binary I/O : Có 2 lớp cha lớn nhất trong Binary I/O là InputStream và OutStream (chúng đều là interface). Các lớp này đều chỉ có các phương thức đọc ghi theo từng byte
  - 17.4.1 : (tr681) Trình bày 2 lớp con kế thừa từ 2 lớp cha interface này là : FileInputStream và FileOutputStream. Hai lớp này chỉ định nghĩa lại các phương thức từ 2 lớp cha, chứ không thêm vào phương thức mới. Do vậy, chúng sẽ chỉ toàn các phương thức đọc ghi theo byte. Cách đọc ghi theo byte thì sẽ phù hợp khi ta đọc toàn bộ file, còn nếu muốn đọc và lấy ra một số int trong file đó thì rất khó, chỉ số int là 4 byte trong khi nó chỉ đọc có 1 byte, nên chẳng biết nên ghép các byte lại như thế nào cả ==> Do vậy, Java sinh ra 2 lớp giúp ta có thể lấy được các kiểu dữ liệu khác như Int, Double, String....
  
  - 17.4.2, 17.4.3: (tr684)Tác giả trình bày 2 class mới là DataInputStream và DataOutputStream được kế thừa từ 2 lớp tương ứng FilterInputStream và FilterOutputStream. 2 lớp trên (DataInputStream và DataOutputStream) sẽ kế thừa thêm từ 1 interface khác là DataInput/DataOutput chứa đựng các phương thức giúp lấy ra được các kiểu dữ liệu như Int, Double, String,... Bên trong 2 class này sẽ định nghĩa lại các method bên trong DataInput/DataOutput. Do vậy, chúng ta có thể ghi/đọc các kiểu dữ liệu Int, double, float, string.... mà không bị giới hạn chỉ bị ghi/đọc được theo byte như FileInputStream và FileOutputStream. Có một lưu ý thêm : Tác giả hay sử dụng writeUTF/readUTF để ghi và đọc string vì đây là cách sử dụng UTF8 với cách mã hóa linh hoạt (Đại khái : với những ký tự ASCII nó sẽ mã hóa bằng 1 byte, với những ký tự khác sẽ mã hóa có thể bằng 2 hoặc 3 byte...). Tác giả nói rằng : hàm writeUTF/readUTF là hiệu quả.
  
  - 17.4.4 : (tr688) Tác giả giới thiệu thêm một stream giúp tăng hiệu suất của quá trình đọc/ghi nhờ sử dụng buffer, nghĩa là : không cần phải thường xuyên thao tác với File (bộ nhớ ngoài) mà giao tiếp thông qua một buffer. Buffer này chỉ lấy một lượng lớn dữ liệu từ File để cho chương trình dùng dần, hoặc ta sẽ ghi hết dữ liệu vào buffer đến khi buffer đầy thì buffer mới đẩy vào file. Hai lớp quản lý buffer đó là : BufferedInputStream và BufferOutputStream. Tham số truyền vào cho BufferOutputStream và BufferedInputStream tương ứng là các đối tượng của Outputstream và InputStream. Để hiểu đơn giản ta hãy quan niệm các kiểu stream chứa dữ liệu như trên là các đoạn đường ống, mỗi đoạn đường ống sẽ có một nhiệm vụ. Ta có thể kết hợp nhiều đoạn đường ống này với nhau nhằm cho quá trình đọc ghi hoạt động tốt nhất có thể. 
    - Ví dụ : 
	  - DataOutputStream output = new DataOutputStream(new BufferedOutputStream(new FileOutputStream("temp.dat"))); : được ghép bởi các đường ống sau : DataOutputStream (đường ống giúp ghi các kiểu dữ liệu tùy ý) --> BufferOutputStream (đường ống sử dụng cơ chế Buffer nhằm tăng hiệu quả của thao tác i/o) --> FileOutputStream (đường ống quả lý dữ liệu theo từng byte) --> File (File dữ liệu ở bộ nhớ ngoài (ổ cứng) của máy tính)
	  - DataInputStream input = new DataInputStream(new BufferedInputStream(new FileInputStream("temp.dat"))); : tương tự cũng được ghép bởi các đường ống DataInputStream (đường ống giúp đọc các kiểu dữ liệu tùy ý) <-- BufferOutputStream (đường ống sử dụng cơ chế Buffer nhằm tăng hiệu quả của thao tác i/o) <-- FileOutputStream (đường ống quả lý dữ liệu theo từng byte) <-- File (File dữ liệu ở bộ nhớ ngoài (ổ cứng) của máy tính)
	- Từ việc hiểu được các kiểu stream (các đường ống với từng chức năng riêng) ta có thể phối hợp các đường ống theo tiêu chí của bài toán một cách phù hợp và hiệu quả nhất.
	
- 17.5 (tr691) : Tác giả trình bày một ví dụ về cách copy từ một file nọ sang file kia.

- 17.6 (tr692) : Tác giả trình bày các đọc và ghi đối tượng object vào file nhị phân nhờ sử dụng ObjectInputStream và ObjectOutputStream. Vậy các lớp này có những chức năng gì? ObjectInputStream được kết thừa từ InputStream (nên có các hàm đọc ghi theo byte), kế thừa từ interface ObjectInput mà ObjectInput lại kết thừa từ interface Datainput (nên vừa các hàm đọc theo từng kiểu dữ liệu cụ thể như int, double, String,..., vừa có hàm readObject trong ObjectInput để đọc được cả đối tượng từ file), ngoài ra thì nó còn kế thừa interface ObjectStreamConstants. Tương tự với sơ đồ kết thừa của ObjectOutputStream. Tác giả đã trình bày khá dễ hiểu trong ví dụ demo.
  - 17.6.1 : (tr695) : Tác giả lưu ý về interface Serializable? Ý nghĩa của interface này là gì? 
    - Tác giả nói rằng : Một đối tượng chỉ có thể được đọc/ghi theo kiểu object vào 1 file nhị phân khi và chỉ khi class của đối tượng này có implements Serializable. Về bản chất thì Serializable chỉ là một interface rỗng (bên trong class của nó không có method), người ta còn gọi là : marker interface. Ví dụ : Khi ta định nghĩa một class C và muốn lưu một đối tượng của class C này dưới dạng object trong file nhị phân, lúc này ta cần phải implements cho class C với Serializable, còn nếu không implements Serializable thì chương trình sẽ báo lỗi và xuất ra ngoại lệ NotSerializableException. Có một câu hỏi đặt ra là : Nếu bên trong class C (đã implements Serializable) chứa một đối tượng thuộc lớp A khác mà lớp A đó chưa implements Serializable, vậy thì đối tượng của lớp C này có thể được lưu dưới dạng đối tượng vào file không? Câu trả lời là : Không vì đối tượng của lớp A (nằm trong class C) chưa được Serializabled. Ta có 2 cách sửa tình huống này : Hoặc sẽ thêm implements Serializable cho lớp A (tức đối tượng của lớp A cũng sẽ được lưu vào file), Hoặc "lờ đi" đối tượng của lớp A trong class C bằng cách thêm vào từ khóa transient trước đối tượng đó (như trong ví dụ trang 695, lúc này đối tượng của lớp A sẽ không được lưu vào file). Một chú ý nữa : Các trường thuộc tính dạng static trong đối tượng C sẽ không được lưu theo dạng Object (nghĩa là JVM sẽ chủ động bỏ đi trường này trong đối tượng object được lưu vào file, điều này cũng dễ hiểu bởi vì biến static là biến của class chứ không phải là biến của object nên việc JVM không lưu trường này là hoàn toàn hợp lý!!!).
	
	- Các kiểu dữ liệu có sẵn trong java đều đã được implements Serializable rồi nhé!!!
	- Vậy có khi nào cùng một object sẽ bị ghi vào nhiều lần trong trong file nhị phân hay không? Câu trả lời là không. Bởi vì hình như với mỗi object khi implements Serializable sẽ được gắn với một mã serial number nhằm phân biệt và tránh một đối tượng bị ghi vào nhiều lần trong file.
	- Còn đối với bản thân các class ObjectInputStream và ObjectOutputStream cũng đã được Java implements một dạng Object Serialization rồi giúp các stream này có thể lưu trữ được cả một mảng hay một ArrayList chứa các đối tượng đã implements Serializable ()
	
  - 17.6.2 (tr696) : Tác giả trình bày về cách lưu đối tượng dạng Array như int[], float[], String[]... theo dạng object. Rõ ràng ta nhìn thấy int, float,... đều là kiểu dữ liệu nguyên thủy không phải đối tượng hay tham chiếu. Nhưng bản thân mảng int[] lại là một kiểu đối tượng (con trỏ) nên Java cũng cho phép lưu kiểu đối tượng mảng (của các kiểu dữ liệu nguyên thủy này)
  
  
## CHƯƠNG 19 : GENERICS 


	  

	