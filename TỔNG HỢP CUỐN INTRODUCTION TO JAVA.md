
# TỔNG HỢP CUỐN INTRODUCTION TO JAVA PROGRAMMING - AUTHOR : Y. DANIEL LIANG

## CHƯƠNG 12 : EXCEPTION HANDLING AND TEXT I/O - Trang 449

- Mục 12.1, 12.2 (tr450) : Tác giả trình bày tổng quan về Exception và Lợi ích mà nó đem lại thông qua các ví dụ : 
  - Listing 12.1, 12.2, 12.3 : Tác giả đưa ra ví dụ sau : Giả sử ta cần phải thiết kế một phương thức (method) để tính thương của 2 số nguyên nhập vào. Khi phương thức đó nhận được 2 tham số này để tính thương, vậy điều gì sẽ xảy ra nếu Tham số thứ 2 bằng 0 (Lỗi chia cho 0). Rõ ràng lúc này, bên trong phương thức đó ta cần phải tính toán và thiết kế thêm một đoạn If để check điều kiện cho tham số thứ 2 phải khác 0. Cụ thể hơn bên trong vòng If đó ta cần phải đưa ra các hướng xử lý cho tình huống này: 
	- Hoặc ngay lập tức thoát khỏi chương trình (dùng exit(1)) ==> Thoát đột ngột, Thiết kế không hiệu quả
	- Hoặc sẽ thông báo người dùng nhập lại ==> Vậy điều gì xảy ra : Nếu với cùng một Exception (lỗi chia cho 0) tại các ngữ cảnh khác nhau thì người ta lại muốn xử lý theo các chiến lược khác nhau (chẳng hạn : thông báo nhập lại, hoặc tự động thiết lập giá trị mặc định,...)??? Ta không nên "đặt cứng" một hướng xử lý ngoại lệ bên trong phương thức được mà hãy để tùy thuộc vào từng bối cảnh khác nhau thì sử dụng một chiến lược xử lý ngoại lệ hợp lý ==> Đó mới là cách thiết kế chuyên nghiệp và dễ kế thừa.
	
  - Vậy cần phải thiết kế như thế nào mới hợp lý :
    - Listing 12.4 (tr452) : Thay vì đặt đồng thời 2 nhiệm vụ : Phát hiện Exception và Xử lý Exception trong cùng 1 method được gọi, thì ta hãy phân tách nó ra : Nhiệm vụ phát hiện Exception được giao cho method (khi method phát hiện ra exception thì nó sẽ phóng exception ra bằng lệnh throw new Tên_Exception()), còn nhiệm vụ Xử lý Exception sẽ được thực hiện bởi caller (nơi mà gọi tới method tính toán thương của 2 số nguyên như trên. Tại caller này, method sẽ được bao bọc bởi Try ... Catch. Nếu method không phóng ra Exception thì chương trình sẽ thực hiện hết các lệnh trong khối Try và bỏ qua các khối Catch. Còn nếu có bất kỳ Exception nào được phóng ra từ trong khối try nghĩa là từ một method nào đó thì nó sẽ nhảy đến khối Catch tương ứng để xử lý loại exception này. Chú ý rằng : Có thể trong khối try có thể chứa đựng nhiều method, mà mỗi method lại có thể phóng ra các loại Exception khác nhau, do vậy cần phải có nhiều khối catch để bắt được tương ứng các Exception đó). Ta hãy quan niệm : Exception thực chất chính là một đối tượng mà thôi, bản chất bên trong class của Exception này cũng không có gì phức tạp cả. Constructor của nó chỉ có tham số String để cho biết Nội dung hay Tên gợi nhắc của Exception này. Vậy ý nghĩa của String (tham số) truyền vào Exception này là gì ? Với Exception thuộc class ArithmeticException như : new ArithmeticException("Lỗi chia cho 0") và new ArithmeticException("Lỗi chia cho một biến không phải là số"). Nếu trong caller (bao bọc bởi khối try..catch) chứa cả 2 phương thức mà có thể phóng ra 2 Exeption "cùng loại mà khác kiểu" như thế này thì phải giải quyết ra sao? Có lẽ lúc đó phải dựa vào thêm số String truyền vào thì mới phân biệt được mỗi exception và có hướng giải quyết tương ứng.
	
	- Listing 12.5 (454) : 
	  - Tác giả muốn nói rằng Tất cả các phương thức có sẵn của thư viện đều đã được trang bị đầy đủ để phóng ra các Exception có tiềm năng xảy ra đối với nó. Lập trình chỉ cần biết : Đối với phương thức này có thể sẽ phóng ra những Exception loại nào, từ đó ở phần caller (lời gọi tới method đó) tại khối Catch sẽ bắt đầy đủ các Exception và xử lý theo ý riêng của Lập trình viên.
	  - Chú ý khi sử dụng : x = input.nextInt() với input là đối tượng của Scanner rằng : sau khi người dùng nhập vào từ bàn phím thì ngay sau lệnh x = input.nextInt() ta nên thêm vào lệnh input.nextLine() để xóa bỏ dòng (buffer) của lần nhập vừa xong (tránh lần nhập sau phải bị dùng lại). Chẳng hạn như : Tại lần nhập này nếu người dùng nhập nhiều số như : 5 6 7, mà nếu sau x = input.nextInt() ta không có input.nextLine() thì sau khi đọc được 5, thì tại lệnh input.nextInt() kết tiếp trong tương lại thì nó sẽ lại đọc tiếp 6 (nguyên nhân : do buffer của System.in trong quá khứ chưa được xóa) ==> Hãy thật lưu ý điều này !!!
	  
- Mục 12.3 (tr455) : Các kiểu Exception - Mọi Exception đều là lớp con (cháu) từ lớp gốc : Throwable
  - Hãy chú ý rằng : Mọi Exception đều là đối tượng, vì thế chúng phải có Class để định nghĩa ra chính mình (exception). Do vậy những lỗi nào mà không có Class biểu diễn nó thì nó không được gọi là Exception (như Lỗi cú pháp không thể gọi là Exception được). Do vậy, những lỗi mà có thể biểu diễn được thông qua một Class (có thể là Class có sẵn cho exception, hoặc Class do ta tự tạo) thì mới được coi là Exception ==> Như vậy, ta đã hiểu rõ : Thế nào là Exception !!!
  - Bên trong Exception thì lại chia thành nhiều dạng khác nhau : 
    - System Error (class Error): Chứa các class mà định nghĩa cho các Exception do lỗi từ bên trong hệ thống gây ra mà lập trình viên ít có khả năng tác động vào được như : Lỗi kết nối (Class LinkageError), Lỗi về máy ảo (Class VirtualMachineError). Khi gặp những lỗi này, ta thường phải ngừng chương trình đang chạy.
	- Exceptions gồm các dạng chính : 
	  - Checked Exceptions : Là kiểu exception mà Compiler (Trình dịch) có khả năng phát hiện và yêu cầu, bắt buộc Lập trình viên phải thêm vào các đoạn Try...catch tương ứng xử lý, ví dụ : IOException (Ngoại lệ về Lỗi Đọc/Ghi File, thông thường trình biên dịch sẽ yêu cầu LTV phải thêm các đoạn xử lý ngoại lệ Try ... catch), hoặc ClassNotFoundException (Lỗi Class không tồn tại, lỗi này có thể phát hiện được bởi Compiler)
	  - Unchecked Exceptions : Là kiểu exception mà chỉ tại running time mới biết được là có xảy ra lỗi hay không? Nghĩa là trình dịch không thể kiểm soát, lường trước được ngoại lệ này. Ví dụ như : ArithmeticException (lỗi chia cho 0, rõ ràng : khi có 2 biến x, y và lấy x/y thì trình biên dịch sẽ chẳng đủ thông minh để hiểu được x/y đang thiếu xử lý những ngoại lệ gì, do vậy Lập trình viên phải tự chủ động bắt Try ... catch cho những ngoại lệ này), NullPointerException(Sử dụng một tham chiếu NULL - chưa trỏ đến đối tượng nào cả), IndexOutOfBoundsException(Sử dụng index vượt quá giới hạn của mảng), IllealArgumentException(sd tham số truyền vào không hợp lệ)
	  
	  
- Mục 12.4 (tr458) : Tác giả trình bày sâu hơn về Exception : 
  - Mô hình xử lý Exception trong Java gồm 3 bước : Khai báo Exception, Phóng ra Exception, Bắt(xử lý) Exception.
    - 12.4.1 : Khai báo Exception (tr458): nghĩa là thêm "throws tên_exception" vào phía sau phần khai báo tên của phương thức (method). Vậy khi nào cần phải có sự khai báo này, và việc khai báo Exception cho phương thức như thế này thì có chức năng là gì? Như ta đã biết có loại exception chính là : checked exception (exception được kiểm soát được bởi Compiler) và unchecked exception (exception không kiểm soát được bởi Compiler). 
	  - Với method có checked exception : Cần throws exception đó trong method, đồng thời khai báo checked exception tại header của method (phía sau tên method) (xem trang 458). Mục đích : Mỗi khi có một caller gọi tới method này thì trình biên dịch sẽ dựa trên khai báo checked exception trên method đó và yêu cầu bắt buộc LTV phải có đoạn Try...catch xử lý, hoặc ít nhất nếu chưa muốn chưa xử Checked Exception tại caller này thì phải tiếp tục khai báo Checked Exception đó trên caller đang gọi (để những caller phía trước sẽ biết và yêu cầu LTV phải xử lý Try ... catch). Chú ý : nếu trong 1 phương thức mà có thể phóng ra nhiều checked exception thì ta cần phải khai báo đủ chúng trên phần header (mỗi exception sẽ cách nhau bởi 1 dấu phẩy)
	  - Với method chỉ có unchecked exception : Thì không cần phải khai báo throws exception bởi vì đây là unchecked exception tức là ngoại lệ mà khó hay không thể kiểm soát bởi compiler (vì các unchecked exception rất là phức tạp và nhiều dạng nên trình biên dịch không đủ thông minh để tự động phát hiện được do vậy LTV phải chủ động phòng ngừa). Vậy nếu ta cố tình vẫn khai báo unchecked exception đó tại header của phương thức thì sao? Khi compiler nhìn thấy sự khai báo exception đó, compiler sẽ biết đó là : unchecked hay checked exception. Nên khi compiler biết đó là : unchecked exception thì compiler sẽ "lờ đi" và "coi như không có sự khai báo này". Để chứng minh sự "lờ đi" của compiler đối với unchecked exception ta có nhìn vào ví dụ sau : nếu tại một lời gọi hàm (caller) tới method đang chứa unchecked exception mà có khai báo thì tại caller nếu ta không có Try...catch hoặc cũng không có throws exception này thì compiler cũng không báo lỗi vì nó biết đây là unchecked exception nên việc phòng ngừa phải do lập trình viên đảm nhận và test thật kỹ !!!
	- 12.4.2 : Phóng ra Exception (tr458-459): Bên trong một phương thức nếu ta nghi ngờ dòng code này có thể xảy ra ngoại lệ thì ta cần phải check trường hợp ngoại lệ đó (xem có xảy ra không), nếu khi xảy ra thì sẽ phóng ra đối tượng ngoại lệ tương ứng với nó theo cú pháp : throw new Tên_Ngoại_Lệ();. Chú ý : Bản chất thì ngoại lệ cũng là một đối tượng nên phải có "new". Từ khóa "throw" trong thao tác phóng ngoại lệ cũng khác với từ khóa "throws" (có thêm s) trong thao tác khai báo ngoại lệ tại header ==> Chú ý !!!  
	- 12.4.3 : Bắt ngoại lệ (tr459-461) : Đây chính là giai đoạn để tìm ra Đoạn xử lý ngoại lệ tương ứng với ngoại lệ đang được phóng ra. Giả sử : Tại main() ta có gọi tới method1(), bên trong method1() ta gọi đến method2(), rồi bên trong method2() ta gọi đến method3(). Bên trong method3() là method có khả năng phát ra ngoại lệ exception1. Khi exception1 được phát ra thì nó sẽ tìm trong các khối Catch trong method3() để tìm ra đoạn xử lý tương ứng với nó, nếu tìm được thì nó sẽ thực hiện khối đó rồi thực hiện tiếp các lệnh sau khối catch (bỏ qua phần còn lại trong khối try). Nhưng nếu không tìm thấy thì sao, hoặc trong method3() không có đoạn try...catch xử lý mà phóng ra (throw) exception đó? Lúc này, chương trình sẽ lần tới method2() tức method cha (method gọi tới method3), rồi lại kiểm tra tương tự trong method2 này. Nếu trong method2 chỉ có throw exception hoặc có try...catch nhưng trong các khối catch thì không tìm thấy đoạn xử lý tương ứng. Lúc này chương trình lại lần tới method1(),... quá trình kiểm tra tương tự. Nếu vẫn không tìm thấy thì rõ ràng chương trình sẽ phóng ra exception và ngừng lại đột ngột !!!

  - 12.4.4 : Cách lấy thông tin từ Exception () (tr461) Tác giả trình bày về cách sử dụng các phương thức lấy thông tin từ một exception bắt được trong khôi Catch ví dụ như : printStackTrace() (lấy thông tin về : tên exception được phóng ra, và nơi xảy ra exception đó,...), toString(), getMessage(),....
  
- Mục 12.5 : Sử dụng Finally (tr466): Khối finally được đặt sau khối Try...catch với mục đích rằng : dù có hay không xảy ra exception thì chương trình sẽ luôn phải thực hiện khối finally đó (thậm chí : ngay cả khi phía trước của finally là một lệnh return)

- Mục 12.6 - Khi nào sẽ nên sử dụng Exception (tr467) : Tác giả nói rằng không lạm dụng Exception một cách bừa bãi (lúc nào cũng sử dụng) mà hãy nên cân nhắc xem : đó là lỗi mà có thể lường trước hay khó lường trước được? Nếu nó là một lỗi "dễ lường trước" và "ít xuất hiện - xuất hiện cá biệt chỉ trong class đó" thì nên sử dụng If () để xử lý luôn. Còn nếu đó là một lỗi "khó lường trước và có thể xuất hiện trong một vài class" thì hãy nên sử dụng Exception (có thể đó là Exception của thư viện hoặc Exception mà ta tự tạo kế thừa từ Exception của thư viện)

- Mục 12.7 - Phóng ra lại Exception (tr468) : Nghĩa là trong khối Catch xử lý exception đó mà ta không xử lý mà lại tiếp tục phóng nó (throw exception). Java có cho phép điều này nhằm đẩy việc xử lý ngoại lệ cho một caller phía trước nó!!!
- Mục 12.8 - Chuỗi exeption (tr469) : Tác giả trình bày các in ra một chuỗi các exception ==> Phần này không quan trọng lắm.
- Mục 12.9 - Định nghĩa một Exception mới. Có một vài điều cần chú ý : 
  - Ta muốn exception mới này là : checked exceptioin hay unchecked exception. Nếu muốn nó sẽ là checked exception thì phải extends class này với class Exception, còn nếu muốn nó sẽ là uncheck exception thì hãy extends nó với RuntimeException. Tác giả khuyên nên sử dụng và tạo ra kiểu checked exception để compiler có thể chủ động nhắc chúng ta thêm các đoạn xử lý ngoại lệ hoặc các đoạn khai báo trên header (nếu ta chưa muốn xử lý ngoại lệ tại ví trí này, và muốn nhường việc xử lý ngoại lệ cho caller phía trước nó)
  - Ví dụ 12.10, 12.11 : Tác giả đưa ra ví dụ về cách tạo ra một Checked Exception. Bản chất của Exception cũng không có gì phức tạp. Nó giống như một thành phần mà Java thêm vào giúp phân tách quá trình phát hiện và xử lý ngoại lệ thành nhiều bước tách rời như Khai báo ngoại lệ, Phóng ngoại lệ và Xử lý ngoại lệ, nhằm giúp cho quá trình code sẽ chuyên nghiệp và dễ hiểu hơn!!!
	  
- 12.10 :(tr473) Tác giả hướng dẫn các sử dụng class File nhằm quản lý một file hay một folder trong máy tính như : xem file/folder có tồn tại, tạo file/folder, đổi tên file/folder, xem kích thước, xóa,...Chú ý rằng File chỉ giúp quản lý lý thông tin gắn với thuộc tính của file hoặc folder chứ lớp này không có tính năng đọc hay ghi file đâu nhé (khi đó cần phải sử dụng lớp Scanner để đọc file text và lớp PrintWriter để ghi vào file text)

- 12.11 (tr476) : Cách sử dụng PrintWriter để ghi file text và sử dụng Scanner để đọc file text. Có một vài chú ý sau : 
  - PrintWriter và Scanner được hiểu là các Stream ghi/đọc từ file nào đó. Ta cần phải truyền vào các PrintWriter hay Scanner một đối tượng File sẽ đọc (đối tượng này đã bàn ở 12.10, nhằm quản lý file đó, kiểm tra file đó có tồn tại, ...). Còn nếu ta muốn đọc từ bàn phím thì truyền vào constructor của Scanner là System.in (đầu vào chuẩn từ bàn phím trong java)
  - PrintWriter, Scanner : có checked exception là IOException được phóng ra khi File đọc vào không tìm thấy (không tồn tại). Do là checked exception nên compiler sẽ buộc yêu cầu Lập trình viên phải có đoạn Try ... Catch xử lý hoặc phải khai báo nó ra tại header của caller đó
  - Thông thường lập trình viên hay quên gọi lệnh close() để giải phóng tài nguyên sử dụng file. Do vậy JDK7 sẽ hỗ trợ thêm cú pháp Try-with-resourse nhằm tự động đóng tài nguyên(close()) sau khi đọc xong file. Đừng nhầm lẫn là nó sẽ giải quyết hộ luôn Exception mà Lập trình viên vẫn phải có đoạn xử lý exception cho nó nhé!!!
  - 12.11.4 (tr479): Tác giả nói rõ hơn cách hoạt động của Scanner như : cách Scanner lấy token ra sao,... để từ đó ta có thành thạo các thao tác liên quan tới đọc file text sd Scanner
  - 12.11.5 (tr480): Trình bày ví dụ về các Thay thế text trong 1 file

- 12.12 :(tr482) Trình bày ví dụ về cách đọc text từ URL (Link trên web). Do không đọc từ File trên máy tính mà đọc từ URL nên ta cũng phải sử dụng một đối tượng thuộc lớp URL để quản lý URL đó
- 12.13 (tr484) : Tác giả trình bày các crawler các link từ một trang web ban đầu theo kỹ thuật quét theo chiều rộng (nghĩa là với một trang web ta sẽ quét hết các URL trong đó, rồi lại truy nhập vào từng URL rồi lại quét... cho tới khi quét đủ 100 URL thì dừng lại)  
	  
	  
# CHƯƠNG 13 (tr496)- ABSTRACT CLASSES AND INTERFACES

- Mục 13.6  (tr509) Tìm hiểu về interface Comparable
  - Comparable là Generic Inteface (nghĩa là có khuôn dạng Comparable<E>, trong đó E cho biết đối tượng được quản lý và kiểm soát bởi Comparable phải là E, tức không được là bất kỳ một kiểu dữ liệu nào khác E. Từ điều này, Compiler chỉ cần nhìn vào khai báo Comparable<E> như Comparable<Integer> thì compiler sẽ báo lỗi nếu ta cố truyền vào tham số mà có kiểu dữ liệu khác E như Double (vì Double khác Integer. Còn nếu không sử dụng Generic mà chỉ sử dụng kiểu đối tượng cha là Object thì compiler sẽ không thể phát hiện được lỗi tại thời điểm biên dịch chương trình vì mọi đối tượng đều có kiểu Object, do vậy sẽ vô cùng nguy hiểm khi lỗi sẽ xuất hiện tại Run Time. Kiến thức Generic sẽ được trình bày trong chương 19-tr737)
  - Comparable là interface mà chỉ có duy nhất một phương thức ảo là compareTo(E doi_tuong); Hãy để ý phương thức này được truyền vào một đối tượng phải có kiểu là E (E là kiểu đã được chỉ được từ trước trong các khai báo kiểu như Comparable<Integer> hoặc Comparable<Double>,... thì E sẽ buộc phải là Integer và Double một cách tương cách)
  - java.util.Arrays.sort(mảng_đối_tượng) sẽ thực hiện sắp xếp mảng các đối tượng (thuộc cùng class), nếu class của các đối tượng này phải implements interface Comparable tức phải override phương thức compareTo() theo cách định nghĩa so sánh giữa các đối tượng này.
  - Các kiểu dữ liệu đối tượng có sẵn trong Java đều đã được implements interface Comparable. Ví dụ như : class Integer đã được java implements Comparable<Integer>, do vậy sẽ phải override phương thức compareTo(Integer đối_tượng). Hãy để ý kỹ : tại sao Integer lại implements Comparable<Integer> mà không phải Comparable, hay Comparable<> (hiểu là Comparable<Object>) hay Comparable<Double> bởi vì : class mong muốn được so sánh là class Integer để tham số truyền vào của phương thức compareTo phải là Integer (compareTo(Integer đối_tượng)) (vì chỉ được so sánh 2 đối tượng thuộc cùng kiểu), hơn nữa : Comparable là generic inteface tức phải chỉ rõ cho compiler biết E trong Comparable<E> là class nào để compiler có thể phát hiện lỗi tại thời gian biên dịch.
  - Khi override phương thức compareTo, kiểu trả về là int với 3 giá trị -1, 0, 1 tương ứng với đối tượng hiện tại nhỏ hơn, bằng hay lớn hơn đối tượng cần so sánh (chỉ định trong tham số). Ta buộc phải return đủ 3 giá trị này trong phương thức compareTo để JVM có thể hiểu rõ được thao tác so sánh của Lập trình viên (từ đó tránh được lỗi lưỡng nghĩa)
  - Phía sau tác giả trình bày các ví dụ cụ thể minh họa rõ ràng cách sử dụng Comparable
  
- Mục 13.7 (tr513) - Tìm hiểu về interface Cloneable :
  - Clonable là marker interface nghĩa là bên trong interface là rỗng (không có bất kỳ phương thức nào). Một class khi implements interface Clonable thì sẽ được JVM đánh dấu (là có thể clonable) và sẽ được sử dụng phương thức clone() trong lớp cha lớn nhất (Object). Ngược lại, nếu không implements Clonable mà cố tình gọi phương thức clone() của lớp cha (Object) thì tại run time sẽ phóng ra exception CloneNotSupportedException (nghĩa là : ta chưa implements Clonable);
  - Các kiểu dữ liệu (class) có sẵn trong Java đều đã được implements Clonable (như Integer, Double, ArrayList,....)
  - Khi ta muốn định nghĩa một class mới có khả năng clonable thì cần phải làm như sau : 
    - Cho class đó implements Clonable
	- Bên trong class này, tiến hành override phương thức Clone của lớp cha Object, về bản chất thì nó sẽ gọi đến chính clone() của lớp cha Object (bằng cách super.clone()) nhưng mở rộng phạm vi nhìn thấy của phương thức này ra thành public (việc mở rộng giúp một đối tượng có thể gọi được phương thức này ở Package chứa class đó) (Xem kỹ ví dụ : House.java, tr514-515)
	- Phương thức clone trong class Object chứa Checked Exception là CloneNotSupportedException, nên khi bất cứ khi nào ta gọi đến phương thức clone của Objec thì compiler luôn yêu cầu : hoặc phải xử lý exeption đó bằng Try..catch hoặc Phải khai báo Exception đó ra (throws CloneNotSupportedException tại header của phương thức mà đang sử dụng clone của Object đó)
	
  - Vấn đề shallow copy và deep copy : 
    - Hiện tượng shallow copy xảy ra khi đối tượng được nhân bản lại chứa các thuộc tính dạng tham chiếu (con trỏ), thậm chí đối tượng mà thuộc tính tham chiếu này trỏ tới có thể lại tiếp tục chứa một dạng tham chiếu khác,... Trong khi clone() chỉ là nhân bản "nông", nó không đủ thông minh để tìm kiếm và nhân bản cho tất cả các tham chiếu (phụ thuộc) ở đằng sâu bên trong.
    - Ví dụ : Khi ta sử dụng ArrayList<Interger> arr1 = ..., sau đó sử dụng ArrayList<Integer> arr2 = (ArrayList<Integer>) arr1.clone(); ==> Ở đây xảy ra hiện shallow copy. Nghĩa là : Rõ ràng arr1, và arr2 nằm ở 2 vùng nhớ hoàn toàn khác nhau tức arr1 != arr2 (không cùng trỏ đến 1 vùng nhớ, khác tham chiếu), nhưng arr1 và arr2 lại chứa cùng danh sách các con trỏ giống hệt nhau, nghĩa là nếu : arr1.get(0).setDoTuoi(100) thì arr2.get(0) cũng sẽ bị thay đổi theo vì 2 con trỏ này đang cùng trỏ tới một vùng nhớ ==> Đây chính là vấn đề : Shallow Copy
	- Để ngăn ngừa Shallow Copy xảy ra thì Lập trình viên phải chủ động phát hiện và lường trước để tiến hành override phương thức clone() giúp tạo ra 2 đối tượng "độc lập thực sự" như tác giả trình bày trong ví dụ tr516, với ý tưởng như sau : 
	  - Khi override phương thức Clone() thì cần phải để tâm tới những thuộc tính dạng tham chiếu rồi tiến hành clone riêng cho từng dạng tham chiếu đó. Làm tương tự, nếu các tham chiếu còn ở sâu sâu bên trong cho tới khi gặp tham chiếu tới đối tượng mà chỉ chứa toàn các kiểu thuộc tính dữ liệu "nguyên thủy" (như int, float, double,...)

- Mục 13.8 (tr517) - Trình bày sự khác nhau giữa Interface và Abstract Class
  - Về kiểu dữ liệu của thuộc tính : 
    - Interface : buộc phải là public static final (tức kiểu hằng, tĩnh, public). Java đã mặc định luôn như vậy nên dù ta có viết như thế nào thì java cũng sẽ chỉ hiểu theo kiểu này
    - Atract Class : không có ràng buộc (giống như thuộc tính trong class bình thường)
	
  - Về kiểu dữ liệu trả về của phương thức : 
    - Interface : buộc phải là public abstract (tức phải luôn là phương thức ảo và có phạm vi nhìn thấy là public). Java đã mặc định luôn như vậy nên dù ta có viết như thế nào thì java cũng sẽ chỉ hiểu theo kiểu này
    - Atract Class : không có ràng buộc (có thể là phương thức abstract hoặc là phương thức bình thường như trong class)
  
  
  - Ta không thể sử dụng new tên_interface() hoặc new tên_abstract_class() vì chúng chỉ là kiểu dữ liệu trừu tượng, nhưng ta có thể thực hiện uploading như sau : 
    - tên_interface obj = new subClass_của_interface(); hoặc tên_abstract_class obj = new subClass_của_abstract_class(); (uploading - ý nghĩa : dùng một kiểu dữ liệu trừu tượng để chứa các đối tượng thuộc kiểu dữ liệu con của nó). 
    - Vậy còn downloading có nghĩa gì? Ta cần phân tích cụ thể như sau : Giả sử có interface1/hoặc abstract1 là cha của class1, class2, class3. Có dòng code : interface1/abstract1 obj = new class2(); (hiện tượng uploading). Đối với interface1 thì luôn chỉ có các phương thức ảo, còn với abstract1 thì có thể có phương thức ảo hoặc phương thức thực (không ảo)
	  - obj chỉ gọi tới hay nhìn thấy được các phương thức như sau : 
	    - Là phương thức ảo trong interface1 hoặc phương thức ảo trong abstract1 nhưng đã được cài đặt (định nghĩa) trong class2. Với các phương thức loại này thì hiển nhiên obj này sẽ gọi đến các phương thức nằm trong class2
		- Là phương thức "thực" trong abstract1 mà không bị override trong class2 ==> Hiển nhiên, obj sẽ gọi đến phương thức nằm trong class cha (abstract1) vì class2 (lớp con) không định nghĩa phương thức này.
		- Là phương thức "thực" trong abstract1 mà có override trong class2 ==> obj sẽ gọi đến phương thức nằm trong lớp con (bởi vì đó là phương thức cụ thể nhất)
	  - obj sẽ không thể gọi tới được các phương thức mà đã được bổ sung trong lớp con, nhưng lại không có mặt trong lớp cha (interface1/abstract1) vì góc nhìn sau khi uploading là góc nhìn của lớp cha (chỉ nhìn thấy các phương thức của lớp cha). Vậy câu hỏi đặt ra là làm sao để có thể nhìn thấy và sử dụng được những phương thức được bổ sung thêm tại các lớp con??? Để làm được điều này, ta cần phải downloading (ép kiểu) xuống chính lớp con đó (góc nhìn của lớp con đó), ví dụ như : obj = (Class2) obj. Lúc này ta có thể nhìn thấy mọi phương thức nằm trong lớp Class 2 và nằm trong mọi lớp cha của nó. Nhưng vấn đề tiếp theo là : làm sao để biết obj là thuộc class2 hay class1 hay class3 (vì 3 class này đều là con của interface1/abstract1) ==> Cần sử dụng toán tử instanceof để kiểm tra : obj instanceof Class1 có trả về true không !!! (tương tự)
  
  - Interface và Abstract Class được sinh ra nhằm chỉ định một Kiểu đối tượng "trừu tượng" như Animal(động vật), ở đây ta không biết được Animal là Cat, Dog, hay Elephent ... Còn một class bình thường sẽ dùng để mô tả cho một class cụ thể. Kiểu dữ liệu trừu tượng này sẽ giúp chứa những đặc điểm chung nhất (thuộc tính, phương thức) của các class con. Vậy sự khác biệt chính giữa Interface và Abstract Class là gì?
    - Abstract Class : 
	  - Tên của Abstract Class luôn là danh từ
	  - Dùng để biểu diễn quan hệ is-a relationship (quan hệ "là") và đó phải là quan hệ thể hiện mạnh mẽ. Ví dụ như : Cat là Animal, Dog cũng là Animal ... Từ đó, người ta định nghĩa Animal như một Abstract Class. Hoặc ví dụ khác : LichDuong (Lịch Dương) cũng là Lich (Lịch), LichAm (Lịch Âm) cũng là Lich, do vậy Lich sẽ là Abstract Class 
	  - Hãy để ý thật kỹ : nếu Abstract Class là Animal thì subclass của nó chắc chắn phải là một dạng animal như Dog, Cat,...không thể là một Đồ ăn hay đồ uống được. Hoặc nếu Abstract Class là Lịch thì subclass của nó chắc chắn cũng là một loại lịch cụ thể như Lịch Âm, Lịch Dương, không thể là một đồ vật hay một loại nước ngọt được.
	
	- Interface : 
	  - Tên của interface : có thể là tính từ hoặc danh từ
	  - Biểu diễn cho quan hệ is-a relationship nhưng là quan hệ yếu. Ví dụ : trong java có interface Comparable (hiểu là : biểu diễn một đặc điểm, một thuộc tính là có thể so sánh). Các class con có thể là : Square implement Comparable (hình vuông) , Retangle implements Comparable (hình chữ nhật),... ==> Chúng biểu thị rằng : Các hình vuông có thể so sánh được với nhau, các hình chữ nhật có thể so sánh được với nhau. Nó là quan hệ yếu bởi vì : Nó chỉ biểu thị rằng : Square hay Rectangle đều sở hữu tính chất (thuộc tính) Comparable (có thể so sánh được). Do vậy, khi muốn biểu diễn việc sở hữu một tính chất hay một thuộc tính thì hãy sử dụng interface.
	  - Các subclass của interface không nhất thiết phải cùng kiểu mà chỉ cần nó sở hữu tính chất đó là được. Ví dụ, ta có thể tạo một lớp con cho Comparable là : Hình vuông, Hình chữ nhật, Bó rau, Ngôi nhà, ... dù Bó rau, Ngôi nhà, Hình vuông đều không cùng dạng hình nhưng chúng đều có thể so sánh được. Như vậy, đây là một đặc trưng rất rõ của interface
  ==> Từ 3 đặc trưng trên ta có thể phân biệt được rõ : khi nào thì cần interface, khi nào thì cần tới abstract class.
	
## CHƯƠNG 17 : BINARY I/O
- 17.1, 17.2, 17.3 (tr678) : Tác giả trình bày về sự khác nhau giữa Text I/O và Binary I/O :
  - Text I/O sử dụng Scanner (Đọc file text) và PrintWriter (Ghi file text) như đã biết trong chương 12
  - Máy tính thì luôn hiểu các file ở dạng nhị phân? Vậy thì sự khác nhau giữa text i/o và binary i/o là gì? 
    - Đối với Text I/O thì sẽ có thêm quá trình encoding và decoding. Nó sẽ hiểu mọi ký tự trong file text đều bằng 1 byte, ví dụ với số 199, thì nó sẽ mã hóa cho từng "1", "9", "9" với các byte sau : 0x31, 0x39, 0x39 (viết theo hệ 16). Việc encoding là để coding từng ký tự thành từng byte (vì nó coi mọi ký tự để là ký tự dạng chữ, dù cho nó là số đếm), còn decoding để dùng khi đọc từ file nhị phân rồi decoding nó sang dạng hệ cơ số 10 là "199", rồi từ "199" lập trình viên mới có thêm lệnh ép kiểu về dạng int như sau : (int)"199" hay bản chất chính là (int)input.nextInt();
	- Đối với Binary I/O thì không có quá trình encoding và decoding mà nó mã hóa trực tiếp : giả sử số 199 sẽ được mã hóa thành 0xC17 (nghĩa là chỉ cần 1 byte để biểu diễn số này, chứ không phải mất tới tận 3 byte như Text I/O)
  - Tác giả nói rằng : Binary I/O hiệu quả hơn Text I/O bởi vì nó cần phải mất thêm quá trình encoding và decoding, hơn nữa cũng tiết kiệm vùng nhớ hơn so với Text I/O.
  
- 17.4 (tr680) : Trình bày về các class sử dụng cho Binary I/O : Có 2 lớp cha lớn nhất trong Binary I/O là InputStream và OutStream (chúng đều là interface). Các lớp này đều chỉ có các phương thức đọc ghi theo từng byte
  - 17.4.1 : (tr681) Trình bày 2 lớp con kế thừa từ 2 lớp cha interface này là : FileInputStream và FileOutputStream. Hai lớp này chỉ định nghĩa lại các phương thức từ 2 lớp cha, chứ không thêm vào phương thức mới. Do vậy, chúng sẽ chỉ toàn các phương thức đọc ghi theo byte. Cách đọc ghi theo byte thì sẽ phù hợp khi ta đọc toàn bộ file, còn nếu muốn đọc và lấy ra một số int trong file đó thì rất khó, chỉ số int là 4 byte trong khi nó chỉ đọc có 1 byte, nên chẳng biết nên ghép các byte lại như thế nào cả ==> Do vậy, Java sinh ra 2 lớp giúp ta có thể lấy được các kiểu dữ liệu khác như Int, Double, String....
  
  - 17.4.2, 17.4.3: (tr684)Tác giả trình bày 2 class mới là DataInputStream và DataOutputStream được kế thừa từ 2 lớp tương ứng FilterInputStream và FilterOutputStream. 2 lớp trên (DataInputStream và DataOutputStream) sẽ kế thừa thêm từ 1 interface khác là DataInput/DataOutput chứa đựng các phương thức giúp lấy ra được các kiểu dữ liệu như Int, Double, String,... Bên trong 2 class này sẽ định nghĩa lại các method bên trong DataInput/DataOutput. Do vậy, chúng ta có thể ghi/đọc các kiểu dữ liệu Int, double, float, string.... mà không bị giới hạn chỉ bị ghi/đọc được theo byte như FileInputStream và FiletputStream. Có một lưu ý thêm : Tác giả hay sử dụng writeUTF/readUTF để ghi và đọc string vì đây là cách sử dụng UTF8 với cách mã hóa linh hoạt (Đại khái : với những ký tự ASCII nó sẽ mã hóa bằng 1 byte, với những ký tự khác sẽ mã hóa có thể bằng 2 hoặc 3 byte...). Tác giả nói rằng : hàm writeUTF/readUTF là hiệu quả.
  
  - 17.4.4 : (tr688) Tác giả giới thiệu thêm một stream giúp tăng hiệu suất của quá trình đọc/ghi nhờ sử dụng buffer, nghĩa là : không cần phải thường xuyên thao tác với File (bộ nhớ ngoài) mà giao tiếp thông qua một buffer. Buffer này chỉ lấy một lượng lớn dữ liệu từ File để cho chương trình dùng dần, hoặc ta sẽ ghi hết dữ liệu vào buffer đến khi buffer đầy thì buffer mới đẩy vào file. Hai lớp quản lý buffer đó là : BufferedInputStream và BufferOutputStream. Tham số truyền vào cho BufferOutputStream và BufferedInputStream tương ứng là các đối tượng của Outputstream và InputStream. Để hiểu đơn giản ta hãy quan niệm các kiểu stream chứa dữ liệu như trên là các đoạn đường ống, mỗi đoạn đường ống sẽ có một nhiệm vụ. Ta có thể kết hợp nhiều đoạn đường ống này với nhau nhằm cho quá trình đọc ghi hoạt động tốt nhất có thể. 
    - Ví dụ : 
	  - DataOutputStream output = new DataOutputStream(new BufferedOutputStream(new FileOutputStream("temp.dat"))); : được ghép bởi các đường ống sau : DataOutputStream (đường ống giúp ghi các kiểu dữ liệu tùy ý) --> BufferOutputStream (đường ống sử dụng cơ chế Buffer nhằm tăng hiệu quả của thao tác i/o) --> FileOutputStream (đường ống quả lý dữ liệu theo từng byte) --> File (File dữ liệu ở bộ nhớ ngoài (ổ cứng) của máy tính)
	  - DataInputStream input = new DataInputStream(new BufferedInputStream(new FileInputStream("temp.dat"))); : tương tự cũng được ghép bởi các đường ống DataInputStream (đường ống giúp đọc các kiểu dữ liệu tùy ý) <-- BufferOutputStream (đường ống sử dụng cơ chế Buffer nhằm tăng hiệu quả của thao tác i/o) <-- FileOutputStream (đường ống quả lý dữ liệu theo từng byte) <-- File (File dữ liệu ở bộ nhớ ngoài (ổ cứng) của máy tính)
	- Từ việc hiểu được các kiểu stream (các đường ống với từng chức năng riêng) ta có thể phối hợp các đường ống theo tiêu chí của bài toán một cách phù hợp và hiệu quả nhất.
	
- 17.5 (tr691) : Tác giả trình bày một ví dụ về cách copy từ một file nọ sang file kia.

- 17.6 (tr692) : Tác giả trình bày các đọc và ghi đối tượng object vào file nhị phân nhờ sử dụng ObjectInputStream và ObjectOutputStream. Vậy các lớp này có những chức năng gì? ObjectInputStream được kết thừa từ InputStream (nên có các hàm đọc ghi theo byte), kế thừa từ interface ObjectInput mà ObjectInput lại kết thừa từ interface Datainput (nên vừa các hàm đọc theo từng kiểu dữ liệu cụ thể như int, double, String,..., vừa có hàm readObject trong ObjectInput để đọc được cả đối tượng từ file), ngoài ra thì nó còn kế thừa interface ObjectStreamConstants. Tương tự với sơ đồ kết thừa của ObjectOutputStream. Tác giả đã trình bày khá dễ hiểu trong ví dụ demo.
  - 17.6.1 : (tr695) : Tác giả lưu ý về interface Serializable? Ý nghĩa của interface này là gì? 
    - Tác giả nói rằng : Một đối tượng chỉ có thể được đọc/ghi theo kiểu object vào 1 file nhị phân khi và chỉ khi class của đối tượng này có implements Serializable. Về bản chất thì Serializable chỉ là một interface rỗng (bên trong class của nó không có method), người ta còn gọi là : marker interface. Ví dụ : Khi ta định nghĩa một class C và muốn lưu một đối tượng của class C này dưới dạng object trong file nhị phân, lúc này ta cần phải implements cho class C với Serializable, còn nếu không implements Serializable thì chương trình sẽ báo lỗi và xuất ra ngoại lệ NotSerializableException. Có một câu hỏi đặt ra là : Nếu bên trong class C (đã implements Serializable) chứa một đối tượng thuộc lớp A khác mà lớp A đó chưa implements Serializable, vậy thì đối tượng của lớp C này có thể được lưu dưới dạng đối tượng vào file không? Câu trả lời là : Không vì đối tượng của lớp A (nằm trong class C) chưa được Serializabled. Ta có 2 cách sửa tình huống này : Hoặc sẽ thêm implements Serializable cho lớp A (tức đối tượng của lớp A cũng sẽ được lưu vào file), Hoặc "lờ đi" đối tượng của lớp A trong class C bằng cách thêm vào từ khóa transient trước đối tượng đó (như trong ví dụ trang 695, lúc này đối tượng của lớp A sẽ không được lưu vào file). Một chú ý nữa : Các trường thuộc tính dạng static trong đối tượng C sẽ không được lưu theo dạng Object (nghĩa là JVM sẽ chủ động bỏ đi trường này trong đối tượng object được lưu vào file, điều này cũng dễ hiểu bởi vì biến static là biến của class chứ không phải là biến của object nên việc JVM không lưu trường này là hoàn toàn hợp lý!!!).
	
	- Các kiểu dữ liệu có sẵn trong java đều đã được implements Serializable rồi nhé!!!
	- Vậy có khi nào cùng một object sẽ bị ghi vào nhiều lần trong trong file nhị phân hay không? Câu trả lời là không. Bởi vì hình như với mỗi object khi implements Serializable sẽ được gắn với một mã serial number nhằm phân biệt và tránh một đối tượng bị ghi vào nhiều lần trong file.
	- Còn đối với bản thân các class ObjectInputStream và ObjectOutputStream cũng đã được Java implements một dạng Object Serialization rồi giúp các stream này có thể lưu trữ được cả một mảng hay một ArrayList chứa các đối tượng đã implements Serializable ()
	
  - 17.6.2 (tr696) : Tác giả trình bày về cách lưu đối tượng dạng Array như int[], float[], String[]... theo dạng object. Rõ ràng ta nhìn thấy int, float,... đều là kiểu dữ liệu nguyên thủy không phải đối tượng hay tham chiếu. Nhưng bản thân mảng int[] lại là một kiểu đối tượng (con trỏ) nên Java cũng cho phép lưu kiểu đối tượng mảng (của các kiểu dữ liệu nguyên thủy này)
  
  
## CHƯƠNG 19 : GENERICS 


	  

	
